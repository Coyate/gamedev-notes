vecotr.clear()会不会释放真正的内存

### linux
经常可以在一些脚本，尤其是在crontab调用时发现如下形式的命令调用：

/tmp/test.sh > /tmp/test.log 2>&1
前半部分/tmp/test.sh > /tmp/test.log很容易理解，那么后面的2>&1是怎么回事呢？

要解释这个问题，还是得提到文件重定向。我们知道>和<是文件重定向符。那么1和2是什么？在shell中，每个进程都和三个系统文件相关联：标准输入stdin，标准输出stdout和标准错误stderr，三个系统文件的文件描述符分别为0，1和2。所以这里2>&1的意思就是将标准错误也输出到标准输出当中。

 

实际上， > 就相当于 1> 也就是重定向标准输出，不包括标准错误。通过2>&1，就将标准错误重定向到标准输出了（stderr已作为stdout的副本），那么再使用>重定向就会将标准输出和标准错误信息一同重定向了。如果只想重定向标准错误到文件中，则可以使用2> file。

### C#
override，static readonly，delegate，异常

值类型，引用类型：https://blog.csdn.net/qiaoquan3/article/details/51202926



### lua

For a,_ in ipairs

###  数学

概率，求物品掉率，二维概率
求物品掉率
条件规划概率


### UML

### bash
标准输出和错误重定向
大于/大于等于写法
Bash，apache



## 数据库

* 数据库事务四大特性：原子性、一致性、分离性、持久性
* 数据库索引：顺序索引、B+ 树索引、hash 索引
[MySQL 索引背后的数据结构及算法原理](http://blog.codinglabs.org/articles/theory-of-mysql-index.html)
* [SQL 约束 (Constraints)](http://www.w3school.com.cn/sql/sql_constraints.asp)

### 范式

* 第一范式（1NF）：属性（字段）是最小单位不可再分
* 第二范式（2NF）：满足 1NF，每个非主属性完全依赖于主键（消除 1NF 非主属性对码的部分函数依赖）
* 第三范式（3NF）：满足 2NF，任何非主属性不依赖于其他非主属性（消除 2NF 主属性对码的传递函数依赖）
* 鲍依斯-科得范式（BCNF）：满足 3NF，任何非主属性不能对主键子集依赖（消除 3NF 主属性对码的部分和传递函数依赖）
* 第四范式（4NF）：满足 3NF，属性之间不能有非平凡且非函数依赖的多值依赖（消除 3NF 非平凡且非函数依赖的多值依赖）