
### space


坐标系
.1 有那几个坐标系(空间)？如何在空间之间转换？
有五个坐标系，分别是：
物体坐标系（本地坐标系）Local Space 或 Model Space
世界坐标系 World Space 
观察者坐标系（摄像机坐标系）View Space 
裁剪空间 Clipping Space 
屏幕空间 Screen Space 


其中前四个矩阵之间需要通过model, view , projection矩阵变换，裁剪空间到屏幕空间通过视口变换进行；前三个是三维空间，后两个是二维空间。
所有的变换都发生在顶点着色器，经过顶点着色器，所有顶点都变成了屏幕上的二维坐标，下一步进行图元装配后进入几何着色器。

1.3 视口变换是什么？
视口变换发生在投影到2D屏幕后，将投影之后归一化的点映射到屏幕上指定的一块区域。在OpenGL中，通过glViewPort指定。

1.12 为什么要用齐次坐标系
方便进行平移变换
能够简化透视投影的计算

### SRT MVP

https://blog.csdn.net/silangquan/article/details/9970673

1.什么是model，view，project矩阵？
世界矩阵(World Matrix)、视图矩阵(View Matrix)以及投影矩阵(Projection Matirx); 
世界矩阵确定一个统一的世界坐标，用于组织独立的物体形成一个完整的场景; 
视图矩阵就是我们能看到的那部分场景，由虚拟摄像机负责拍摄； 
投影矩阵就是3维物体的平面影射.把三维场景在一个二维的平面上显示.

1.2 三个重要的空间变换矩阵？作用？
需要注意这三个矩阵都在顶点着色器中应用。
Model matrix 模型矩阵。进行从物体坐标到世界坐标的转换。控制了物体的平移、旋转、缩放。在3D建模软件中为模型坐标，导入游戏后使用model matrix 进行大小、位置、角度的设置
View matrix 观察矩阵。将世界坐标系变换到观察者坐标系，通过一些列平移、旋转的组合来移动整个场景（而不是移动摄像机，摄像机 是一个虚拟概念，事实上代码中并没有摄像机camera，而是用view matrix来表示摄像机，然后把view matrix附加到每一个物体，来模拟摄像机），用来模拟一个摄像机
projection matrix 投影矩阵。将观察者坐标系转换到裁剪坐标系。将3D坐标投影到2D屏幕上，裁剪空间外的顶点会被裁剪掉，投影矩阵指定了坐标的范围。


判点在三角形类，求交算法,非法四元数？运算量比矩阵大？方向表达方式唯一






### rotate

四元数	非法四元数？运算量比矩阵大？方向表达方式唯一？

1.14 旋转的三种方法与对比
旋转矩阵 4x4
欧拉角 yaw pitch roll 
四元数
知道欧拉角吗：知道 pitch，yaw...会万向节死锁，没用过
1.15 四元数 Quaternion 的概念和作用
https://blog.csdn.net/silangquan/article/details/39008903

http://blog.csdn.net/candycat1992/article/details/41254799
四元数本质上是一种高阶复数（听不懂了吧。。。），是一个四维空间，相对于复数的二维空间。我们高中的时候应该都学过复数，一个复数由实部和虚部组成，即x = a + bi，i是虚数单位，如果你还记得的话应该知道i^2 = -1。而四元数其实和我们学到的这种是类似的，不同的是，它的虚部包含了三个虚数单位，i、j、k，即一个四元数可以表示为x = a + bi + cj + dk。那么，它和旋转为什么会有关系呢？
在Unity里，tranform组件有一个变量名为rotation，它的类型就是四元数。很多初学者会直接取rotation的x、y、z，认为它们分别对应了Transform面板里R的各个分量。当然很快我们就会发现这是完全不对的。实际上，四元数的x、y、z和R的那三个值从直观上来讲没什么关系，当然会存在一个表达式可以转换。

1.16 四元数、欧拉角、旋转矩阵的优点和缺点
矩阵旋转
优点：
旋转轴可以是任意向量；
缺点：
旋转其实只需要知道一个向量+一个角度，一共4个值的信息，但矩阵法却使用了16个元素；
而且在做乘法操作时也会增加计算量，造成了空间和时间上的一些浪费；

欧拉旋转
优点：
很容易理解，形象直观；
表示更方便，只需要3个值（分别对应x、y、z轴的旋转角度）；但按我的理解，它还是转换到了3个3*3的矩阵做变换，效率不如四元数；
缺点：
之前提到过这种方法是要按照一个固定的坐标轴的顺序旋转的，因此不同的顺序会造成不同的结果；
会造成万向节锁（Gimbal Lock）的现象。这种现象的发生就是由于上述固定坐标轴旋转顺序造成的。理论上，欧拉旋转可以靠这种顺序让一个物体指到任何一个想要的方向，但如果在旋转中不幸让某些坐标轴重合了就会发生万向节锁，这时就会丢失一个方向上的旋转能力，也就是说在这种状态下我们无论怎么旋转（当然还是要原先的顺序）都不可能得到某些想要的旋转效果，除非我们打破原先的旋转顺序或者同时旋转3个坐标轴。这里有个视频可以直观的理解下；
由于万向节锁的存在，欧拉旋转无法实现球面平滑插值；

四元数旋转
优点：
可以避免万向节锁现象；
只需要一个4维的四元数就可以执行绕任意过原点的向量的旋转，方便快捷，在某些实现下比旋转矩阵效率更高；
可以提供平滑插值；
缺点：
比欧拉旋转稍微复杂了一点点，因为多了一个维度；
理解更困难，不直观；

### normal

9.顶点法线和面法线的作用。

面法线，垂直于平面，位于中央，经常用于flat着色。

点的法线是在使用Phone或Gouraud模型时计算光照使用。如果一个面上的所有法线都一样，他们的光照也就一样，就会产生 flatness 效果；而如果把每个顶点的法向设置不同，则更平滑。

### math

2.1 平面上N个点，每两个点都确定一条直线， 求出斜率最大的那条直线所通过的两个点
平面上N个点，每两个点都确定一条直线，
求出斜率最大的那条直线所通过的两个点（斜率不存在的情况不考虑）。时间效率越高越好。


平面上N个点，每两个点都确定一条直线，求出斜率最大的那条直线所通过的两个点（斜率不存在的情况不考虑）。时间效率越高越好。
关于这道题，网上已经给出了解答要点：
3个点A,B,C,把它们的按x坐标排序。假设排序后的顺序是ABC，那么有两种情况：
1.ABC共线，则k(AB)=k(BC)=k(AC)
2.ABC不共线，则ABC将形成一个三角形，那么k(AC)<max(k(AB), k(BC))
其中k()表示求斜率。
所以程序的基本步骤就是：
1.把N个点按x坐标排序。
2.遍历，求相邻的两个点的斜率，找最大值。
时间复杂度Nlog(N)。
先把这些点按x坐标从小到大排序，斜率最大的两点必然是挨一起的两个点，所以排序O(n* lg n)，遍历一次O(n)就够了

8.平面上N个点，每两个点都确定一条直线， 求出斜率最大的那条直线所通过的两个点（斜率不存在的情况不考虑）时间效率越高越好。
程序的基本步骤就是：
1.把N个点按x坐标排序。
2.遍历，求相邻的两个点的斜率，找最大值。
时间复杂度Nlog(N)


7.两圆相交，只有2交点A、B，过A点做线段CAD，CA、AD为两圆的弦，问什么情况下CAD最长，并证明。提示圆心角和圆周角的两倍关系。


如图分别连接BC，BD。当CAD不断的变化的时候，可以得到个无数个三角形CBD，这些三角形的夹BCA和角BDA都是相同的，分别是BA对应的圆心角的一半。

则这些三角形都是相似的。

那么当BD最大的时候，也就是三角形最大的时候，也就是CAD最长的时候。

BD最大的时候就是BD为圆的直径，则BAD为直角，同理，BAC也是直角=>BA 垂直CAD。


#### Intersection

https://blog.csdn.net/silangquan/article/details/17464821