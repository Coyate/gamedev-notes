## 定义

`排序`: 输入序列的一个重排，使得k_1^′≤k_2^′≤k_3^′≤…≤k_n^′  (或者相反)    
- 并不是所有的排序都基于比较
- 对任意序列进行基于比较的排序，对n个关键字排序的比较次数为[log_2⁡n! ]
- ↑当关键字随机排列时，任意两个关键字的比较都可以用二叉判定树描述，所以任意基于比较的排序的时间复度都不会低于O(n log⁡n)

`稳定性`: 排序前R_i=R_j 且R_i 位于R_j 前面，排序后R_i 仍在R_j 前面  
`内部排序`: 元素全部存放再内存中  
`外部排序`: 排序期间元素无法全部存放在内存中，需要在内外存中移动  

`最终`：每趟都有一个元素被放在最终位置上  



| 种类 | 算法     | 最好       | 平均       | 最坏       | 空间复杂度 | 是否稳定 | 是否最终 | 最好情况            | 最坏情况                                           |
| :--- | :------- | :--------- | :--------- | :--------- | :--------- | :------- | :------- | :------------------ | :------------------------------------------------- |
| 插入 | 直接插入 | O(n)       | O(n^2)     | O(n^2)     | O(1)       | ✔       | ✖       | 基本有序，n−1次比较 | 倒序，n(n−1)/2 次比较                              |
|      | 折半插入 | O(nlog⁡n)  | O(n log⁡n) | O(n^2)     | O(1)       | ✔       | ✖       | -                   | 基本有序，每次查找退化到O(n)，划分两侧分别为0和n-1 |
|      | 希尔排序 |            | O(n^1.3)   |            | O(1)       | ✖       | ✖       | -                   | -                                                  |
| 交换 | 冒泡排序 | O(n)       | O(n^2)     | O(n^2)     | O(1)       | ✔       | ✔       | 基本有序            | 倒序                                               |
|      | 快速排序 | O(n log⁡n) | O(n log⁡n) | O(n^2)     | O(log⁡n)   | ✖       | ✖       | 每次都刚好二分      | 基本有序，每次都会划分两半的差距巨大               |
| 选择 | 简单选择 | O(n^2)     | O(n^2)     | O(n^2)     | O(1)       | ✖       | ✔       | -                   | -                                                  |
|      | 堆排序   | O(n log⁡n) | O(n log⁡n) | O(n log⁡n) | O(1)       | ✖       | ✔       | -                   | -                                                  |
| 归并 | 二路归并 | O(n log⁡n) | O(n log⁡n) | O(n log⁡n) | O(n)/O(1)  | ✔       | ✖       | -                   | -                                                  |
|      | 基数     | O(d(n+r))  | O(d(n+r))  | O(d(n+r))  | O(r)       | ✔       | ✖       | -                   | -                                                  |
|      |          |            |            |            |            |          |          |                     |                                                    |



`插入排序`
- 直接插入排序：前插后移，一般用于链表
- 折半插入排序：搜索时采用二分搜索，插入后移时是一样的
- 希尔排序 Shell Sort：又称为缩小增量排序
	- 取距离d_t，对下标为[i, i+d,i+2d…i+kd]进行插入排序
	- 取d_(t−1)<d_t，对新的下标集合进行排序，减少d直到d=1，
	- 一般取d_t=n/2,d_(t−1)=[d_t/2]


`交换排序`  
`冒泡排序`：从后往前交换出最小元素  
- 可以同时从前往后交换最大元素，称为双向冒泡排序

`快速排序`：取pivot，用双指针交换pivot两侧的元素，划分后对pivot两侧再递归快排  
- 当子序列规模较少时可以换成直插排序
- 随机选中pivot可以避免最坏情况
- 在序列头，尾，正中三个值中选取中间的值作为pivot

`选择排序`  
`简单选择排序`：选最大的或者最小的，Swap  

`堆排序`  
堆是一棵完全二叉树，每个节点的关键字都比孩子节点关键字小的堆叫小根堆，反之称为大根堆。
- 建大根堆：对下标小于等于[n/2]的结点（有孩子的节点），先从[n/2]开始，若该节点比孩子小，则swap，若swap后孩子节点不满足堆的属性，再继续调整孩子，一直到调整完整个堆
- 排序：每次将堆顶输出，再将堆底放到堆顶，调整好堆再输出即为排序序列
- 插入：插入到堆底，向上调整


`归并排序`

`2路归并排序`：设一开始有n个记录，看为n个长度为1的有序子表，再两两合并，得到[n/2]个长度为2的有序子表，如此两两合并直到长度为n  
- 两两合并时一般需要一个O(n)大小的辅助数组来将两个子表合并
- 可以用手摇算法而不使用辅助数组
	
`k路归并排序`：每次将k路归并

`基数排序`：又称为桶排序，是一种分配式排序。关键字有d位，每个范围为[0,r−1]，建立一个大小为r的桶（包含了r个链表），然后按LSD/MSD（Least/Most Significant Digit First，最高位优先，最低位优先）将关键字放入桶中再取出，称为一次分配与收集，分配收集d次后既可以得到排序序列  
	

`外部排序`
外部排序指待排序文件较大，无法放在内存中，需要存放在外部介质中的排序。

`外部排序的过程`

1. 生成归并段
	- 利用置换-选择排序增大归并段长度，减少归并段数量  
	- 置换选择排序是通过在工作区中流式比较生成初始归并段的排序方法  

`FI`：待排文件，设为{17,21,05,44,10,12,56,32,29}  
`WA`：工作区，容量固定，设为3  
`FO`：输出区  

文件从FI里进到WA，然后从WA里找关键字最小的记录，放到FO，记作MinMax，再从FI里读到WA，然后在WA里比MinMax大的关键字集合中找最小值放到FO，更新MinMax，重复此举直到WA中找不到MinMax。

	FO：{05,17,21,44,56}
	§ 一般可以生成两倍WA大的归并段
	§ 选MinMax的过程使用败者树
		
2. 多路平衡归并
	1. 用败者树加速m路归并中的比较
		- 将m路各自的最小关键字看作完全二叉树的叶节点，两两比较后更小的才能进行下一步比较，比较次数O(log_2⁡n )
	1. 长度不等的归并段可以通过构造最佳归并树来进行多路平衡归并
		- 最佳归并树，严格m叉哈夫曼树，少了补0，0放在最远的位置，总Io次数为2×WPL
		

外部排序计算  
文件有4500个记录，每个磁盘块能装下75个记录，内存中可以容纳450个记录。
1. 初始的归并段为4500/450 = 10个
2. 每个归并段有450/75 = 6 个 记录，存放于6个内存块中
3. 内存可容纳6个块，其中五个输入，一个输出，可以使用5路归并排序
4. 需要两趟归并，每趟归并需要读60个块，写60个块
5. 归并的总时间= 10 * 块内排序时间 + 120 * 2 * 外存读写时间 + 2 * 4500 * 单次取最小关键字时间
	
`t_es=r×t_IS+d×t_IO+S×n×t_mg`
若初始r个归并段，m路平衡归并，第一趟可以将r个归并为[r/m]个，同理可得归并树的高度为S=log_m⁡r，可以通过减少归并段数量r或增大归并路数m来节省时间  

在内存中做m路内部归并时，找出m路最小的关键字需要比较m-1次，每趟归并n个元素，则S趟归需要比较的总次数为 S×(n−1)×(m−1)=log_r⁡m×(n−1)×(m−1)  
增大m时，内部归并的总次数也会上升  
引入败者树后，败者树深度为log_2⁡m，则比较的总次数变为log_r⁡m×(n−1)×log_2⁡m=(n−1)×log_2⁡r，变得与m无关，但m太大时，内存缓冲区变量会增多。  
