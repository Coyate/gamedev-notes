## 树

当N=0时为空树

树的逻辑结构：
1. 除根节点外有且只有一个前驱节点
2. 所有节点可以有零个或多个后继节点

基础名词：分支节点，叶子节点，双亲节点，孩子节点，祖先节点，子孙节点，节点的度，树的度，层次，高度（自底向上），深度（自顶向下）
- 结点总数等于度加一


树的性质

1. 节点数等于所有的节点的度+1
2. 度为m的第i层至多有m^(i−1)个节点
3. 高度为h的m叉树至多有(m^ℎ−1)/(m−1)个节点
	1+m+m^2+…+m^n=(m^0 (1−m^n ))/(m−1)=(m^n−1)/(1−m)
4. 有n个节点的m叉树最小高度为[〖log〗_m (n∗(m−1)+1]
5. 叶子节点数量 n_0=n_2+2∗n_3+…+(m−1)∗n_m+1
	树的总节点数 n=n_0+n_1+…+n_m
	节点数等于所有节点的度+1 => n=1∗n_1+2∗n_2…+m∗n_m
	两式相减，叶子节点数量 n_0=n_2+2∗n_3+…+(m−1)∗n_m+1
6. 满m叉树节点 i 的
	- 第1个子女下标为 (i - 1) * m + 2
	- 第k个子女下标为 (i - 1) * i 
	- 双亲下标为 [(i - 2) / m] + 1

## 森林


- 树中节点数比边数多 1（图顶点n，生成树有n+1条边）
- 森林非叶子节点的数量为 n，对应二叉树右指针为空的数量为 n+1
- 森林叶子节点的数量为m，对应的二叉树左指针为空的数量也为 m
	
	
存储方式
1. 顺序存储，双亲表示法
2. 顺序存储，孩子表示法
3. 二叉链表，孩子兄弟表示法

```c++
struct TreeNode {
	int data;
	TreeNode   *firstchild, *nextsibling
}
```

## 二叉树

`二叉树`
与度为2的树相比，二叉树可以为空，单个孩子也有左右次序  
1. N_0=N_2+1
2. 第 k 层最多有 2^(k−1) 个节点

`满二叉树`
高度为h的满二叉树节点总共有2^ℎ−1个  
对于编号为 i 的节点，其双亲节点为 [i / 2]，左孩子为 2i, 右孩子为 2i+1  

`完全二叉树`
1. n 个节点的完全二叉树
	-  i <= [ n / 2 ] 的节点为分支节点
	-  i > [ n / 2 ] 的节点为叶子节点
	- 高度为 [〖log〗_2 (n+1)]  或 [〖log〗_2 (n)]+1
	- i 所在的高度为 [〖log〗_2 (i+1)]  
2. 度为 1 的节点只可能有一个，且只有左孩子
	- n 为奇数时没有度为 1 的节点
	- n 为偶数时，n / 2 处为度为1的节点
3. 层高为 h 的完全二叉树至多有 2^ℎ−1个节点，至少有2^(h1) 个节点


`线索二叉树`
增加 ltag，rtag 两项，用来标识没有左右孩子时指向了前驱和后继  


二叉树的存储
- 顺序存储：从下标 1 开始存储可以满足上述规律  
- 链式存储：n 个节点的二叉链表有 n+1 个空链域  

二叉树的遍历

| 先序遍历     |  中序遍历   | 后序遍历      | 层次遍历      |
|----------|---------|-----------|-----------|
| PreOrder | InOrder | PostOrder | Hierarchy |
| NLR      | LNR     | LRN       |


时间复杂度 o(n), 空间复杂度 o(h) 栈深
- 先中，中后，层中可以确定二叉树的构造
- 三种遍历的叶子节点顺序完全相同

||||
|----|----|-----|
| 树  | 森林 | 二叉树 |
| 先根 | 先序 | 先序  |
| 后根 | 后序 | 中序  |

## 树的应用

`二叉排序树，二叉查找树 Binary Search Tree`
L < N, R > N，中序遍历可以得到递增的序列   
- 用连续插入来建树，插入到叶节点
- 删除时，左子树空可以对换右子树，右子树空可以和左子树兑换，左右子树皆空可以用中序遍历第一个节点对换
- 平均查找性能o(log(n))，最坏O(n)
	 
`AVL树，平衡二叉树 Self-Balancing Binary Search Tree`
含有 n 个结点的平衡二叉树最大深度为 〖Log〗_2 n  
LL，RR，LR，RL，怎么插就怎么转  

- 平衡二叉树最少节点的情况是所有非叶子节点的平衡因子都为1

`哈夫曼树，Huffman Tree`
哈夫曼树构造：找两个最小的合并  
带权路径长度： ∑24_(i=1)^n▒〖u_i∗l_i 〗，路径长度乘以权值之和  
哈夫曼编码：用频度构造哈夫曼树，左0右1可得前缀编码  
因为左右子树顺序无所谓，所以哈夫曼树不唯一  

`并查集`

有Union，Find找根操作

||||||||||
|---|---|---|--|---|---|--|---|---|
|  | 0 |   |  | 1 |   |  | 2 |   |
| 6 | 7 | 8 |  | 4 | 9 |  | 3 | 5 |

合并之前

||||||||||
|----|----|----|---|---|---|---|---|---|---|
| 0  | 1  | 2  | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
| -4 | -3 | -3 | 2 | 1 | 2 | 0 | 0 | 0 | 1 |

Union后，将1接到0上

||||||||||
|----|---|---|---|---|---|---|---|---|---|
| 0  | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
| -7 | 0 |   |   | 1 | 1 | 0 | 0 | 0 | 1 |