---
layout: post
title: "类型"
date: 2018-10-25 20:24:39
update: 
categories: C++
img:
---

- [自定义类型](#自定义类型)
	- [结构体 `struct`](#结构体-struct)
	- [类 `class`](#类-class)
		- [C++ 中 struct 和 class](#c-中-struct-和-class)
	- [枚举 `enum`](#枚举-enum)
	- [联合 `union`](#联合-union)
- [类型转换](#类型转换)
	- [显示转换 `cast`](#显示转换-cast)
	- [static_cast](#static_cast)
	- [dynamic_cast](#dynamic_cast)
	- [const_cast](#const_cast)
	- [reinterpret_cast](#reinterpret_cast)
	- [bad_cast](#bad_cast)
	- [C风格隐式转换](#c风格隐式转换)
- [RTTI](#rtti)
	- [dynamic_cast](#dynamic_cast)
	- [typeid](#typeid)
	- [type_info](#type_info)




### 自定义类型
 内置类型
#### 结构体 `struct`

#### 类 `class`



##### C++ 中 struct 和 class

默认继承权限不同，class继承默认是private继承，而struct默认是public继承
class还可用于定义模板参数，像typename，但是关键字struct不能同于定义模板参数
如果没有定义构造函数，且所有成员变量全是public的话，可以用大括号初始化。
关于默认访问权限

1）默认的继承访问权限。struct是public的，class是private的

2）struct作为数据结构的实现体，它默认的数据访问控制是public的，而class作为对象的实现体，它默认的成员变量访问控制是private的。


总的来说，struct 更适合看成是一个数据结构的实现体，class 更适合看成是一个对象的实现体。
区别

* 最本质的一个区别就是默认的访问控制
    1. 默认的继承访问权限。struct 是 public 的，class 是 private 的。  
    2. struct 作为数据结构的实现体，它默认的数据访问控制是 public 的，而 class 作为对象的实现体，它默认的成员变量访问控制是 private 的。


聚合类 Aggr
字面值常量类 
满足以下条件的为聚合类
	• 数据成员都是字面值类型（算术类型，指针，引用）或字面值常量类
	• 至少有一个constexpr构造函数，constexpr构造函数必须初始化所有成员
	constexpr Debug(bool b = true) : hw(b), io(b), othre(b) {} = default
	• 类内初始值必须为常量表达式，若成员为类类型，则该类类型的初始值必须使用其自身的constexpr构造函数
	• 必须使用默认的析构函数


#### 枚举 `enum`

限定作用域的枚举类型

```cpp
enum class open_modes { input, output, append };
```

 不限定作用域的枚举类型

```cpp
enum color { red, yellow, green };
enum { floatPrec = 6, doublePrec = 10 };
```

enum及其内存
枚举变量是全局变量的情况下， 枚举值的缺省值是0，不是枚举的第一个值。 其他情况，其值是不定的，而且不限定于所列出的枚举值。
enum只是定义了一个常量集合，里面没有“元素”，枚举类型是当做int类型存储的， sizeof值都为4 ，并且系统为其初始化为0；
enum string{    
    x1,    
    x2,    
    x3=10,    
    x4,    
    x5,    
} x;
函数外访问x，x的值为0

默认从 1 开始。。后面的为前面的加1，如果有显式定义的值，则后面的仍然按照显式定义的值加一


#### 联合 `union`
union只能保存一个类型的值，其他类型此时是未定义的。。如果都是内置类型，则编译器会合成构造和拷贝控制函数进行转换，如果 union 内部带有类类型...那就要手动管理
一般采用一个判别式，判断 union 的值目前到底是那个类型的
```C++
union Token {
	char cval;
	int ival;
	double dval;
}
Token t = {'1'}; // 默认给第一个成员赋值
```




联合（union）是一种节省空间的特殊的类，一个 union 可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。当某个成员被赋值后其他成员变为未定义状态。联合有如下特点：

* 默认访问控制符为 public
* 可以含有构造函数、析构函数
* 不能含有引用类型的成员
* 不能继承自其他类，不能作为基类
* 不能含有虚函数
* 匿名 union 在定义所在作用域可直接访问 union 成员
* 匿名 union 不能包含 protected 成员或 private 成员
* 全局匿名联合必须是静态（static）的

<details><summary>union 使用</summary> 
 
```cpp

union UnionTest {
    UnionTest() : i(10) {};
    int i;
    double d;
};

static union {
    int i;
    double d;
};

int main() {
    UnionTest u;

    union {
        int i;
        double d;
    };

    std::cout << u.i << std::endl;  // 输出 UnionTest 联合的 10

    ::i = 20;
    std::cout << ::i << std::endl;  // 输出全局静态匿名联合的 20

    i = 30;
    std::cout << i << std::endl;    // 输出局部匿名联合的 30

    return 0;
}
```

</details>



### 类型转换
类型转换分为三类
隐式转换 Implicit conversion
算术转换 Arithmetic conversion
整数提升 Integral promotion
	• 宽度小于整数的有无符号类型的算术表达式在计算之前都会被转换为整型
	例：
		unsigned char a = 0xa5;
		unsigned char b = ~a>>4+1;
		printf("%d", b); 
		// ~高于+高于>>
		// 先取反，取反时将unsigned char提升为int
		// 0xa5 -> 0x000000a5;
		// 取反后 0xffffff5a;
		// 再右移5位，最后8位为 0x 1111 1010，截断成unsigned char

	1. 若无符号和有符号对象参与运算，那个类型宽转换成那个
	2. 数组名会自动转换为指针，但是在decltype，&，sizeof，typeid中不发生
	3. 指针转换
		a. 0和nullptr能转换为任意类型的指针
		b. 指向任意非常量的指针能转换为void*类型的指针
		c. 指向任意类型的指针能转换为const void*的指针
	4. 即使定义了explict构造函数，进行直接初始化时类型提升和算术转换也能被容忍，拷贝初始化时不能容忍类型提升和算术转换
		a. 基本类型不是类类型的，只允许一步类类型转换
	5. 


	2. 不是bool类型与bool比较，bool类型会被提升，会判断出错
* 错误示范：if(val == true) // 会变成 if(val == 1)

#### 显示转换 `cast`


转换	说明
static_cast	一般的转换,静态类型转换，如int转换成char
dynamic_cast	通常在基类和派生类之间转换时使用,命名上理解是动态类型转换，如子类和父类之间的多台类型转换
const_cast	主要针对const的转换,字面上理解就是去const属性。
reinterpret_cast	用于进行没有任何关联之间的转换，比如一个字符指针转换为一个整数型,重新解释类型

https://www.cnblogs.com/luntai/p/5879026.html
https://www.cnblogs.com/TenosDoIt/p/3175217.html

6.C++中四种类型转换符。
const_cast，字面上理解就是去const属性。
static_cast，命名上理解是静态类型转换。如int转换成char。
dynamic_cast，命名上理解是动态类型转换。如子类和父类之间的多态类型转换。
reinterpreter_cast，仅仅重新解释类型，但没有进行二进制的转换。

cast_name<type>(expression)

	1. static_cast 
	double slope = static_cast<double>(j)/I;
	void *p = &d; 
	double *dp = static_cast<doube *>(p);
	2. const_cast 去除或添加const
	const char *pc;
	char *p = const_cast<char *>(pc);
	3. reinterpret_cast 变成其他类型，很危险，一般不用
	int *ip;
	char *cp = reinterpret_cast<char *>(ip);
	4. dynamic_cast 运行时类型识别

	
	https://www.learncpp.com/cpp-tutorial/12-9-dynamic-casting/



#### static_cast

* 用于非多态类型的转换
* 不执行运行时类型检查（转换安全性不如 dynamic_cast）
* 通常用于转换数值数据类型（如 float -> int）
* 可以在整个类层次结构中移动指针，子类转化为父类安全（向上转换），父类转化为子类不安全（因为子类可能有不在父类的字段或方法）

> 向上转换是一种隐式转换。

#### dynamic_cast

* 用于多态类型的转换
* 执行行运行时类型检查
* 只适用于指针或引用
* 对不明确的指针的转换将失败（返回 nullptr），但不引发异常
* 可以在整个类层次结构中移动指针，包括向上转换、向下转换

#### const_cast 

* 用于删除 const、volatile 和 __unaligned 特性（如将 const int 类型转换为 int 类型 ）

#### reinterpret_cast

* 用于位的简单重新解释
* 滥用 reinterpret_cast 运算符可能很容易带来风险。 除非所需转换本身是低级别的，否则应使用其他强制转换运算符之一。
* 允许将任何指针转换为任何其他指针类型（如 `char*` 到 `int*` 或 `One_class*` 到 `Unrelated_class*` 之类的转换，但其本身并不安全）
* 也允许将任何整数类型转换为任何指针类型以及反向转换。
* reinterpret_cast 运算符不能丢掉 const、volatile 或 __unaligned 特性。 
* reinterpret_cast 的一个实际用途是在哈希函数中，即，通过让两个不同的值几乎不以相同的索引结尾的方式将值映射到索引。

#### bad_cast

* 由于强制转换为引用类型失败，dynamic_cast 运算符引发 bad_cast 异常。

<details><summary>bad_cast 使用</summary> 

```cpp
try {  
    Circle& ref_circle = dynamic_cast<Circle&>(ref_shape);   
}  
catch (bad_cast b) {  
    cout << "Caught: " << b.what();  
} 
```

</details>



#### C风格隐式转换

[MSDN . 强制转换运算符](https://msdn.microsoft.com/zh-CN/library/5f6c9f8h.aspx)


隐式类型转换
	1. 浮点数转为整型，没有溢出的情况下，会抛弃小数点后的部分
	2. 浮点数转为整型，在溢出的情况
	3. 无符号值与 int 在一个表达式里时，int会转为无符号数
	unsigned u = 10;
	int i = -42;
	std::cout << u + i << std::endl;
	4. 不要混用有无符号型！

显式类型转换
例：引用转换
	float a = 1.f;
	cout << (int)a << endl;		// 1
	cout << (int&)a << endl;	// 1065353216
	// (int&)a == static_cast<int&>(a);
	cout << (int)&a << endl;
	// (int)&a == reinterpret_cast<int>(&a);
	
	float b = 0.f;
	cout << (int)b << endl;		// 0
	cout << (int&)b << endl;	// 0
(int&)a 是把该浮点数地址开始的sizeof(int)个字节的内容当作int


野蛮转换
例：
class A {
public:
	A() { a = 1; b = 2; }
	~A() {}

	int a;
	int b;
};

class B {
public:
	B() { c = 3; }
	~B() {}
	void fun() {
		cout << c << endl;
	}

	int c;
};

int main() {
	A a;
	B* pb = (B*)(&a);
	pb->fun(); // 1
	cout << endl;

	cout << &A::a << endl; // 1
	cout << &A::b << endl; // 1
	cout << &B::c << endl; // 1
}

类中成员变量存储的是偏移量，pb是强制将A的地址看作B类型，调用B的fun函数，fun函数输出偏移为1的成员，则输出了A::a.
若B有两个成员，A只有一个成员，偏移都为1，B的函数输出第二个成员，则fun会输出随机值...

例：
	int *ptr;
	ptr = (int*)0xabcf;
	*ptr = 0xaabb;
运行时异常，写入异常

	
隐式转换要比static_cast强
A继承B
A* pA = (A*)pB;
A* pA = static_cast<A*>(pB);// Not allowed



```C++ 
类转换

class A {
	int a;
};

class B {
	int b;
};

class C : public A, public B{
	int c;
};

int main() {
	C* pC = new C;
	B* pB = dynamic_cast<B*>(pC);
	A* pA = dynamic_cast<A*>(pC);

	if (pC == pB)
		cout << "pC equals to pB" << endl;
	if (int(pC) == int (pB))
		cout << "int(pC) equals to int(pB)" << endl;


	cout << "pC : " << pC << endl;	// 00E7E910
	cout << "pB : " << pB << endl;	// 00E7E914
	cout << "pA : " << pA << endl;	// 00E7E910
	cout << "int(pC) : " << int(pC) << endl;		// 15198480
	cout << "int(pB) : " << int(pB) << endl;		// 15198484
	cout << "int(pA) : " << int(pA) << endl;		// 15198480
	

	return 0;
}


```


### RTTI

#### dynamic_cast

* 用于多态类型的转换

#### typeid

* typeid 运算符允许在运行时确定对象的类型
* type\_id 返回一个 type\_info 对象的引用
* 如果想通过基类的指针获得派生类的数据类型，基类必须带有虚函数
* 只能获取对象的实际类型

#### type_info

* type_info 类描述编译器在程序中生成的类型信息。 此类的对象可以有效存储指向类型的名称的指针。 type_info 类还可存储适合比较两个类型是否相等或比较其排列顺序的编码值。 类型的编码规则和排列顺序是未指定的，并且可能因程序而异。
* 头文件：`typeinfo`

<details><summary>typeid、type_info 使用</summary>

```cpp
class Flyable                       // 能飞的
{
public:
    virtual void takeoff() = 0;     // 起飞
    virtual void land() = 0;        // 降落
};
class Bird : public Flyable         // 鸟
{
public:
    void foraging() {...}           // 觅食
    virtual void takeoff() {...}
    virtual void land() {...}
};
class Plane : public Flyable        // 飞机
{
public:
    void carry() {...}              // 运输
    virtual void take off() {...}
    virtual void land() {...}
};

class type_info
{
public:
    const char* name() const;
    bool operator == (const type_info & rhs) const;
    bool operator != (const type_info & rhs) const;
    int before(const type_info & rhs) const;
    virtual ~type_info();
private:
    ...
};

class doSomething(Flyable *obj)                 // 做些事情
{
    obj->takeoff();

    cout << typeid(*obj).name() << endl;        // 输出传入对象类型（"class Bird" or "class Plane"）

    if(typeid(*obj) == typeid(Bird))            // 判断对象类型
    {
        Bird *bird = dynamic_cast<Bird *>(obj); // 对象转化
        bird->foraging();
    }

    obj->land();
};
```

</details>





10.什么是RTTI？
RTTI(Run-Time Type Information)运行时类型检查的英文缩写，它提供了运行时确定对象类型的方法，通过RTTI，能够通过基类的指针或引用来检索其所指对象的实际类型。c++通过下面两个操作符提供RTTI：
（1）typeid：返回指针或引用所指对象的实际类型。
（2）dynamic_cast：将基类类型的指针或引用安全的转换为派生类型的指针或引用。
对于带虚函数的类，在运行时执行RTTI操作符，返回动态类型信息；对于其他类型，在编译时执行RTTI，返回静态类型信息。

<type_traits>
标准类型转换模板

typeid, type_info, dynamic_cast
dynamic_cast 可以转换指针/右值，或者转换左值到引用
如果接受的参数是带有虚函数的，则dynamic_cast会去寻找该参数的公有基类或公有派生类，如果转换指针失败，会返回一个0，如果转换引用失败，会抛出一个 bad_cast'

typeid 可以得到一个对象的类型，<type_traits>
	• 顶层 const 会被忽略
	• 引用会返回引用所指对象的类型
	• 数组/函数不会转换成指针，会得到数组类型和函数类型
	• 若不包括虚函数，则在编译期计算，内部表达式也不会求值
	• 若包括虚函数，则在运行时计算，会对其求值
	• 若里面是不带有虚函数的指针，则可以为空指针，若带有虚函数，则会抛出 bad_typeid 的异常

type_info
可以判断相等，不等，可以返回名字，比较编译器定义其的顺序
typeid(int).name()
	• 其没有默认构造，拷贝构造，移动构造，赋值运算符都被删除，所以无法定义或拷贝这类对象，也不能为这类对象赋值，创建其的唯一途径是typeid运算符

RTTI
时间开销：整型比较，取址操作
空间开销：type_info
dynamic_cast 对类操作会让指针在类层次中查找