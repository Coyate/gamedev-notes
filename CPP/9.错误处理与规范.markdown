- [错误处理](#错误处理)
	- [异常](#异常)
	- [断言](#断言)
- [模板](#模板)
- [可变形参](#可变形参)
- [Effective C++](#effective-c)
- [Google C++ Style Guide](#google-c-style-guide)

### 错误处理

#### 异常


Q: 我如何使用异常处理？
A: 参见《The C++ Programming Language》14章8.3节，以及附录E。附录E主要阐述如何撰写“exception-safe”代码，这个附录可不是写给初学者看的。一个关键技巧是“资源分配即初始化”——这种技巧通过“类的析构函数”给易造成混乱的“资源管理”带来了“秩序的曙光”。

异常处理机制
	1. throw 表达式（throw expression）：表示检测出了异常，通常说throw引发（raise）了异常
	2. try语句块（try block）：try语句块通常用来处理异常，通常由一个或数个catch子句（catch clause）组成，throw出的异常会被某个catch语句处理，所以被称作异常处理代码（exception handler）中
	3. 异常类（exception class）
	
	while(cin >> item1 >> item2)
		try {
			if (item1.isbn() != item2.isbn())
			throw runtime_error("Data must be same ISBN");
		} catch(runtime_error err) {
			cout << err.what() // 逻辑异常的子函数，返回err存储的字符串, const char* 
			<< "\nTry Again? Enter y or n" << endl;
			char c;
			cin >> c;
			if (!cin || c == ' ')
			break;
		} catch () {} // other catch
	}
	
	• 处理异常时会逐层回退寻找catch，若没有相应异常的catch，会跳转到标准库的terminate，结束程序，一般情况会引发程序非正常退出
	• 处理异常时若再引发了异常，只再处理一次，若无法处理，则直接跳转到terminate



标准库异常
exception	<exception>	通用异常类
bad_alloc	new	
bad_case	<type_info>	
runtime_error	<stdexcept>	运行时才能检测出的问题
range_error		生成的结果超过了有意义的值域范围
overflow_error		
underflow_error		
logic_error		
domain_error		参数对应的结果值不存在
invalid_argument		无效参数
length_error		超出类型最大长度的对象
out_of_range		
	• exception只能默认初始化，返回内容由编译器决定，其他异常必须用string或c风格字符串初始化


noexpect
对编译器说明这个函数不会抛出异常
作用：使用vector时，如果不知道移动构造函数不会发生异常，它就会使用拷贝构造函数


安全异常 Exception Safe
异常通常会终止程序，而此时应用程序正在终端，对象或资源没有释放或进行处理，从而导致对象处于无效的状态，在异常期间进行“清理”的代码称为安全异常代码，主要考虑在异常发生后确保对象有效，资源无泄漏，程序处于正常状态



异常，析构函数，逗号表达式，位域初始化的异常，vector的插入异常安全，异常安全，断言

#### 断言

断言，是宏，而非函数。assert 宏的原型定义在`<assert.h>`（C）、`<cassert>`（C++）中，其作用是如果它的条件返回错误，则终止程序执行。如：

```cpp
assert( p != NULL );
```


assert <cassert>
assert 是一种预处理宏 preprocessor marco
预处理由预处理器管理，在编译器之前
	assert(expr)； // expr为0时，输出并停止程序
	
宏的名字必须唯一
	#define NDEBUG // 停用所有assert
	
调试帮助变量
	用来提供更多错误提示信息
__FUNC__	存放当前函数名字
__FILE__	当前文件名
__LINE__	当前行号
__TIME__	当前编译时间
__DATE__	当前日期




### 可变形参




### Effective C++

1. 视 C++ 为一个语言联邦（C、Object-Oriented C++、Template C++、STL）
2. 尽量以 `const`、`enum`、`inline` 替换 `#define`（宁可以编译器替换预处理器）
3. 尽可能使用 const
4. 确定对象被使用前已先被初始化（构造时赋值（copy 构造函数）比 default 构造后赋值（copy assignment）效率高）
5. 了解 C++ 默默编写并调用哪些函数（编译器暗自为 class 创建 default 构造函数、copy 构造函数、copy assignment 操作符、析构函数）
6. 若不想使用编译器自动生成的函数，就应该明确拒绝（将不想使用的成员函数声明为 private，并且不予实现）
7. 为多态基类声明 virtual 析构函数（如果 class 带有任何 virtual 函数，它就应该拥有一个 virtual 析构函数）
8. 别让异常逃离析构函数（析构函数应该吞下不传播异常，或者结束程序，而不是吐出异常；如果要处理异常应该在非析构的普通函数处理）
9. 绝不在构造和析构过程中调用 virtual 函数（因为这类调用从不下降至 derived class）
10. 令 `operator=` 返回一个 `reference to *this` （用于连锁赋值）
11. 在 `operator=` 中处理 “自我赋值”
12. 赋值对象时应确保复制 “对象内的所有成员变量” 及 “所有 base class 成分”（调用基类复制构造函数）
13. 以对象管理资源（资源在构造函数获得，在析构函数释放，建议使用智能指针，资源取得时机便是初始化时机（Resource Acquisition Is Initialization，RAII））
14. 在资源管理类中小心 copying 行为（普遍的 RAII class copying 行为是：抑制 copying、引用计数、深度拷贝、转移底部资源拥有权（类似 auto_ptr））
15. 在资源管理类中提供对原始资源（raw resources）的访问（对原始资源的访问可能经过显式转换或隐式转换，一般而言显示转换比较安全，隐式转换对客户比较方便）
16. 成对使用 new 和 delete 时要采取相同形式（`new` 中使用 `[]` 则 `delete []`，`new` 中不使用 `[]` 则 `delete`）
17. 以独立语句将 newed 对象存储于（置入）智能指针（如果不这样做，可能会因为编译器优化，导致难以察觉的资源泄漏）
18. 让接口容易被正确使用，不易被误用（促进正常使用的办法：接口的一致性、内置类型的行为兼容；阻止误用的办法：建立新类型，限制类型上的操作，约束对象值、消除客户的资源管理责任）
19. 设计 class 犹如设计 type，需要考虑对象创建、销毁、初始化、赋值、值传递、合法值、继承关系、转换、一般化等等。
20. 宁以 pass-by-reference-to-const 替换 pass-by-value （前者通常更高效、避免切割问题（slicing problem），但不适用于内置类型、STL迭代器、函数对象）
21. 必须返回对象时，别妄想返回其 reference（绝不返回 pointer 或 reference 指向一个 local stack 对象，或返回 reference 指向一个 heap-allocated 对象，或返回 pointer 或 reference 指向一个 local static 对象而有可能同时需要多个这样的对象。）
22. 将成员变量声明为 private（为了封装、一致性、对其读写精确控制等）
23. 宁以 non-member、non-friend 替换 member 函数（可增加封装性、包裹弹性（packaging flexibility）、机能扩充性）
24. 若所有参数（包括被this指针所指的那个隐喻参数）皆须要类型转换，请为此采用 non-member 函数
25. 考虑写一个不抛异常的 swap 函数
26. 尽可能延后变量定义式的出现时间（可增加程序清晰度并改善程序效率）
27. 尽量少做转型动作（旧式：`(T)expression`、`T(expression)`；新式：`const_cast<T>(expression)`、`dynamic_cast<T>(expression)`、`reinterpret_cast<T>(expression)`、`static_cast<T>(expression)`、；尽量避免转型、注重效率避免 dynamic_casts、尽量设计成无需转型、可把转型封装成函数、宁可用新式转型）
28. 避免使用 handles（包括 引用、指针、迭代器）指向对象内部（以增加封装性、使 const 成员函数的行为更像 const、降低 “虚吊号码牌”（dangling handles，如悬空指针等）的可能性）
29. 为 “异常安全” 而努力是值得的（异常安全函数（Exception-safe functions）即使发生异常也不会泄露资源或允许任何数据结构败坏，分为三种可能的保证：基本型、强列型、不抛异常型）
30. 透彻了解 inlining 的里里外外（inlining 在大多数 C++ 程序中是编译期的行为；inline 函数是否真正 inline，取决于编译器；大部分编译器拒绝太过复杂（如带有循环或递归）的函数 inlining，而所有对 virtual 函数的调用（除非是最平淡无奇的）也都会使 inlining 落空；inline 造成的代码膨胀可能带来效率损失；inline 函数无法随着程序库的升级而升级）
31. 将文件间的编译依存关系降至最低（如果使用 object references 或 object pointers 可以完成任务，就不要使用 objects；如果能过够，尽量以 class 声明式替换 class 定义式；为声明式和定义式提供不同的头文件）
32. 确定你的 public 继承塑模出 is-a 关系（适用于 base classes 身上的每一件事情一定适用于 derived classes 身上，因为每一个 derived class 对象也都是一个 base class 对象）
33. 避免遮掩继承而来的名字（可使用 using 声明式或转交函数（forwarding functions）来让被遮掩的名字再见天日）
34. 区分接口继承和实现继承（在 public 继承之下，derived classes 总是继承 base class 的接口；pure virtual 函数只具体指定接口继承；非纯 impure virtual 函数具体指定接口继承及缺省实现继承；non-virtual 函数具体指定接口继承以及强制性实现继承）
35. 考虑 virtual 函数以外的其他选择（如 Template Method 设计模式的 non-virtual interface（NVI）手法，将 virtual 函数替换为 “函数指针成员变量”，以 `tr1::function` 成员变量替换 virtual 函数，将继承体系内的 virtual 函数替换为另一个继承体系内的 virtual 函数）
36. 绝不重新定义继承而来的 non-virtual 函数
37. 绝不重新定义继承而来的缺省参数值，因为缺省参数值是静态绑定（statically bound），而 virtual 函数却是动态绑定（dynamically bound）

### Google C++ Style Guide
Taichi

<details><summary>Google C++ Style Guide 图</summary>

![Google C++ Style Guide](http://img.blog.csdn.net/20140713220242000)

> 图片来源于：[CSDN . 一张图总结Google C++编程规范(Google C++ Style Guide)](http://blog.csdn.net/voidccc/article/details/37599203)

</details>
