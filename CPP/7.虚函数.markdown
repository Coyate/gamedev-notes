---
layout: post
title: "虚函数"
date: 2018-08-30 17:42:59
update: 2018-10-25 11:21:30
categories: C++
img:
---

&emsp;&emsp; 理一下虚函数相关的基础概念，以及虚函数的各种使用场景。包括虚函数使用时的一些较佳实践，和一些需要注意的地方。

<span id="Content">目录</span>

- [虚函数介绍](#虚函数介绍)
- [使用虚函数](#使用虚函数)
- [需要注意的地方](#需要注意的地方)
	- [1. 默认参数是静态绑定的](#1-默认参数是静态绑定的)
	- [2. 返回参数不同的虚函数](#2-返回参数不同的虚函数)
	- [3. 调用特定版本的虚函数](#3-调用特定版本的虚函数)
- [什么场合使用虚函数？](#什么场合使用虚函数)
	- [1. 虚析构](#1-虚析构)
	- [2. 纯虚函数与抽象类](#2-纯虚函数与抽象类)
	- [3. 在类中其他地方使用虚函数](#3-在类中其他地方使用虚函数)
	- [设计使用虚函数的类](#设计使用虚函数的类)
- [虚表](#虚表)
- [多继承与虚继承](#多继承与虚继承)
- [虚函数指针、虚函数表](#虚函数指针虚函数表)
- [虚继承](#虚继承)
- [虚继承、虚函数](#虚继承虚函数)
- [类的布局](#类的布局)
- [虚函数的性能与开销](#虚函数的性能与开销)
- [多态简介](#多态简介)


### 虚函数介绍

&emsp;&emsp; 虚函数是基类希望其派生类进行覆盖的函数。当使用指针或引用调用虚函数时，会检查指针指向的是基类还是派生类，并执行相应版本的函数。

<details><summary>虚函数的基本用法</summary>

```C++
class Base
{
public:
	virtual void function1() {
		std::cout << "Base" << std::endl;
	};
};

class Derived : public Base
{
public:
	virtual void function1() override {
		std::cout << "Derived" << std::endl;
	};
};

int main() {
	Derived d1;
	Base *p = &d1;
	p->function1(); //  "Derived"
	return 0;
}
```
</details>

&emsp;&emsp; 虚函数用指针可以调用到相应类中的同名同参函数。这也是面向对象的**多态**性，不同类型的同名接口表现出不同行为。在 C++ 的面向对象体系中，子类可以**重写 (override)**父类的函数，使得子类在同样的接口表现出不一样的行为。


### 使用虚函数

虚函数的一些规则：
1. 继承类中**重写 (override) **的虚函数的函数名与形参列表必须一致，返回类型也要一致

2. 一旦一个函数被定义为 `virtual`，则该函数在整个继承体系里都是虚函数，即使子类的函数没有 `virtual` 关键字
   
3. `virtual` 会去掉类内函数的内联属性 (`inline`)，因为内联函数可能会被编译器优化掉，不能在运行中动态确定位置。

4. 在 C++11 的新标准中，引入了 `override` 和 `final`，使用这两个限定符可以获得编译器的帮助。


<details><summary> `override` 显式重载 </summary>

``` C++
class Base
{
public:
  virtual void function();
};

class Derived : public Base
{
public:
  virtual void fnuction();
};
```
&emsp;&emsp;在上面这个例子里，`Derived` 类的函数名写错了，但编译器会认为 `Derived` 类声明了一个新的函数。这个问题只有等到运行时才会被暴露出来。

``` C++
class Derived : public Base
{
public:
  virtual void fnuction() override; // compile error, function is not an override
};
```

</details>

&emsp;&emsp;如果添加了限定符 `override`，若没有可以重写的函数，编译器就会报错。

<details><summary> `final` 的用法</summary>

``` C++
class Base
{
public:
  virtual void function() final;
};

class Derived : public Base
{
public:
  virtual void function(); // compile error, cannot override
};
```

</details>

&emsp;&emsp;假如不需要再继承此函数，可以使用 `final` 来获得编译器的帮助，当重写加上了 `final` 限定符的虚函数时，编译器会报错说无法重写。`override` 和 `final` 的功能和 `const` 差不多，都可以帮助我们把问题暴露在编译期。只要有需要，尽量都加上。

### 需要注意的地方

#### 1. 默认参数是静态绑定的

<details> <summary> 静态绑定示例 </summary>

``` C++
class Base
{
public:
	virtual void function(int a = 0) {
		std::cout << "Base : " << a << std::endl;
	};
};

class Derived : public Base
{
public:
	virtual void function(int b = 1) override {
		std::cout << "Derived : " << b << std::endl;
	};
};

int main() {
	Derived d;
	Base *p = &d;
	p->function();	// Derived : 0
	return 0;
}
```

</details>

&emsp;&emsp;虚函数的默认实参是在编译期决定的，当编译器发现调用的参数个数少了，就把默认参数传入。所以在这个例子里，`p` 的静态类型为 `Base *`，编译器根据其静态类型预先分配好了默认参数，程序又在运行时根据其动态类型找到了 `Derived` 的虚函数，所以结果为 `Derived : 0`。    

> 最好不要在重写虚函数时的更改默认实参，如果非要有默认实参，可以在非虚函数中指定默认参数，然后在非虚函数中调用虚函数

> 更不要在子类中隐藏非虚函数的默认实参，最好是不要在子类隐藏非虚函数

#### 2. 返回参数不同的虚函数

&emsp;&emsp;这是虚函数的一个特例，如果父类返回的是一个类的指针或引用，重写的函数可以返回其继承类的指针或引用。虽然允许这样写，但重写的函数仍然只会返回**父类的**指针或引用。

<details> <summary> 示例 </summary>

```C++
class Base
{
public:
	virtual Base* getPointer() {
		std::cout << "get Base" << std::endl;
		return this;
	}
	void printType() {
		std::cout << "Base" << endl;
	}
};

class Derived : public Base
{
public:
	virtual Derived* getPointer() override {    // covariant return type
		std::cout << "get Derived" << std::endl;
		return this;
	}
	void printType() {
		std::cout << "Derived" << endl;
	}
};

int main()
{
	Derived d;
	Base *b = &d;
	d.getPointer()->printType(); // get Derived, Derived
	b->getPointer()->printType(); // get Derived, Base
	return 0;
}
```

 `getPointer` 函数返回的分别是 `Base *` 和 `Derived *`。使用 `d` 对象直接调用函数时，首先调用了 `Derived::getPointer()`，得到了 `Derived *` 类型的 `this` 指针，再通过这个指针调用了非虚函数 `Derived::printType()`。

 使用指针 `b` 调用对象时，因为`Base::getPointer()`是虚函数，所以会调用`Derived::getPointer()`，虽然这个函数返回 `Derived *`，但因为这个虚函数的基类版本返回的是 `Base *`，所以返回的 `this` 会被转换成 `Base *`，导致之后调用了 `Base::printType()`。

</details>

#### 3. 调用特定版本的虚函数
可以通过作用域限定符 `::` 调用特定版本的虚函数。

<details> <summary> 示例 </summary>

```C++
d.getPointer()->Base::getPointer()->printType();
//  get Derived, get Base, Base
```
通过 `d` 得到了 `Derived *` 类型的指针，但可以通过 `Base::` 作用域限定符去调用 `Base::getPointer`。 

</details>

### 什么场合使用虚函数？
#### 1. 虚析构

&emsp;&emsp;如果一个类会被继承，那么它的析构函数需要是虚函数。

<details> <summary> 例子 </summary>


```C++
class Base
{
public:
	~Base() {
		std::cout << "~Base" << std::endl;
	}
};

class Derived : public Base
{
private:
	int *p;
public:
	Derived(int size) {
		p = new int[size];
	}
	~Derived() {
		std::cout << "~Derived" << std::endl;
		delete[] p;
	}
};

int main()
{
	Derived *d = new Derived(100);
	Base *b = d;
	delete b; // ~Base
	return 0;
}
```
上面这个例子中，`delete b` 时，`b` 是 `Base *` 类型，通过 `b` 去析构其指向的 `Derived` 类，因为析构函数不是虚函数，调用的是 `Base` 的析构函数，并没有清理掉 `Derived` 类的成员，造成了内存泄漏。

</details>

&emsp;&emsp;**会被继承的类必须要使用虚析构**。不继承的类不需要虚析构，因为虚函数比普通函数要消耗更多的性能。

<details> <summary> 虚析构 </summary>

``` C++
class Base
{
public:
	virtual ~Base() {
		std::cout << "~Base" << std::endl;
	}
};
```

</details>

> STL 容器都是非虚析构，最好不要继承

#### 2. 纯虚函数与抽象类

<details> <summary> 抽象类示例 </summary>

&emsp;&emsp;在面向对象编程中，经常会有抽象概念，比如说视频文件，而我们播放的是某种格式的视频文件。

```C++
class VideoFile
{
public:
	virtual void play() {
		std::cout << "VideoFile" << std::endl;
	}
};

class mp4 : public VideoFile {
public:

};

int main()
{
	mp4 m;
	m.play(); // Video File
	return 0;
}

```
&emsp;&emsp;假如忘记写 mp4 的播放函数了，然后又播放了mp4，这样就会调用基类的 `play` 函数。而且，我们也不希望基类函数的 `play` 有任何行为，但如果基类的 `play` 函数体为空，我们连播放 mp4 出错了都不知道。

&emsp;&emsp;C++ 提供了纯虚函数来解决这个问题。

```C++
class VideoFile
{
public:
	virtual void play() = 0;
};
class mp4 : public VideoFile {
public:
	// compile error : pure virtual function Videofile::play() has no override
};

int main()
{
	VideoFile v; // compile error : object of abstract class type is not allowed
	return 0;
}
```

</details>

&emsp;&emsp;在一个类中定义了纯虚函数后，该类就会被编译器视为抽象类，不能生成该类的对象。另外，编译器也会强制要求抽象类的继承类 `override` 纯虚函数。之前说的问题都可以通过纯虚函数来解决。

&emsp;&emsp;纯虚函数是为了抽象类而存在的，抽象类一般都是基类，只为了提供接口，便于继承。没有成员的抽象类也被称为接口类。

&emsp;&emsp;纯虚函数也可以有函数体，但只能放在类外，不能嵌入。

<details> <summary> 有函数体的纯虚函数</summary>

``` C++
class VideoFile
{
public:
	virtual void play() = 0;
};

void VideoFile::play() {
	std::cout << "File format is not supported" << std::endl;
}

class mp4 : public VideoFile {
public:
	virtual void play() override {
		VideoFile::play();
	}
};

int main()
{
	VideoFile v; // compile error : object of abstract 
	mp4 m;
	m.play(); // File format is not supported
	return 0;
}
```

</details>


&emsp;&emsp;有函数体的纯虚类仍然不能生成对象，但可以为继承类提供一个默认实现，可以手动调用。

> **纯虚析构**必须要有定义

&emsp;&emsp;当子类被析构时，必定会调用父类的析构函数，即使父类的析构是纯虚析构，也需要定义函数体，否则链接器会报错。

> 什么时候该选用纯虚函数呢？

- 基类不需要实例化
- 子类基本都需要 `override` 基类的虚函数时
- 抽象类的析构函数必须是纯虚函数

> 什么时候不用虚函数呢？

- 不需要多态特性时
- 不是基类，不要虚析构

|函数类型|功能|
| :-: | :-|
|纯虚函数|只继承接口|
|虚函数|继承接口和一份默认实现|
|非虚函数|继承接口和一份强制实现</br>（**不要**隐藏非虚函数）|


#### 3. 在类中其他地方使用虚函数

>**构造函数**可以被声明成虚函数吗？需要被声明成虚函数吗？

&emsp;&emsp;构造函数并不能被声明成虚函数。在一个对象构造时，这个对象的类型还不是完整的（有成员还没有生成完），并不能确定这个对象是什么类型。而虚函数是要通过对象的动态类型来解析的，显然不能将虚函数的机制运用在构造函数上。




Q: C++中为何没有虚拟构造函数？
A: 虚拟机制的设计目的是使程序员在不完全了解细节（比如只知该类实现了某个界面，而不知该类确切是什么东东）的情况下也能使用对象。但是，要建立一个对象，可不能只知道“这大体上是什么”就完事——你必须完全了解全部细节，清楚地知道你要建立的对象是究竟什么。所以，构造函数当然不能是虚的了。
 
不过有时在建立对象时也需要一定的间接性，这就需要用点技巧来实现了。（详见《The C++ Programming Language》，第三版，15.6.2）这样的技巧有时也被称作“虚拟构造函数”。我这里举个使用抽象类来“虚拟构造对象”的例子：

```C++
	struct F {	// interface to object creation functions
		virtual A* make_an_A() const = 0;
		virtual B* make_a_B() const = 0;
	};

	void user(const F& fac)
	{
		A* p = fac.make_an_A();	// make an A of the appropriate type
		B* q = fac.make_a_B();	// make a B of the appropriate type
		// ...
	}

	struct FX : F {
		A* make_an_A() const { return new AX();	} // AX is derived from A
		B* make_a_B() const { return new BX();	} // BX is derived from B
	
	};

	struct FY : F {
		A* make_an_A() const { return new AY();	} // AY is derived from A
		B* make_a_B() const { return new BY();	} // BY is derived from B

	};

	int main()
	{
		user(FX());	// this user makes AXs and BXs
		user(FY());	// this user makes AYs and BYs
		// ...
	}
 ```
 
看明白了没有？上述代码其实运用了Factory模式的一个变体。关键之处是，user()被完全孤立开了——它对AX，AY这些类一无所知。（嘿嘿，有时无知有无知的好处 ^_^）

> 构造与析构函数内部可以使用虚函数吗？

&emsp;&emsp; 如上所述，在对象构造时，该类型还不完全，构造函数内部的函数会被静态地当作该类型的成员函数。虽然可以在构造函数中使用虚函数，但意义不大。

&emsp;&emsp; 析构的时候也是类似的，析构会先调用子类的析构，再调用基类的析构。如果在这期间调用虚函数，可能会调用已经析构了的子类对象的函数，这是很危险的。所以析构函数里的虚函数也会被静态地当作该类型的成员函数。

>**静态成员函数**可以是虚函数吗？

&emsp;&emsp;静态成员函数 (`static` member function) ，动态多态，这两个从命名上来说就没有交集。静态成员函数是编译期绑定的，其在调用的时候不会传入 `this` 指针，也无从判别其动态类型了。

> 虚函数可以是 **`inline` 内联函数**吗？

&emsp;&emsp;`inline` 可以用来修饰虚函数，但当用指针或引用调用虚函数时，编译器并不知道运行时调用的是哪个类型的虚函数，此时内联申请会被忽略。
&emsp;&emsp;当使用对象来调用虚函数时，编译器可以确认调用的类型，该次调用会被内联。

> 在非虚函数里调用虚函数会怎么样？

&emsp;&emsp;类的成员函数在被调用时都会得到 `this` 指针（除了静态成员函数），在成员函数内部调用虚函数，等同于通过 `this` 指针去调用虚函数。例如在 `func1()` 中调用 `virtual func2()`，`func2()` 会是动态绑定的，要注意的是， `func1()`还是静态绑定的。

> 输出流运算符需要是虚函数吗？

&emsp;&emsp;通常，输出一个类对象需要一个输出流的友元函数 (`friend`)，如果不使用虚函数，那就需要给继承体系中每一个子类都添加一个友元函数。但是，友元函数并不是类的成员函数，不能给友元函数添加 `virtual` 关键字。

&emsp;&emsp;可以采用在非虚函数里调用虚函数的方法，在基类友元函数的函数体中调用另一个自定义的输出虚函数。就可以保证整个继承体系都能被输出了。

<details> <summary> 输入流示例 </summary>

```C++
class Base
{
public:
	friend std::ostream& operator<<(std::ostream &out, const Base &b)
	{
		return b.print(out);
	}

	virtual std::ostream& print(std::ostream& out) const
	{
		out << "Base";
		return out;
	}
};

class Derived : public Base
{
public:
	virtual std::ostream& print(std::ostream& out) const override
	{
		out << "Derived";
		return out;
	}
};

```
</details>

#### 设计使用虚函数的类



* 抽象类：含有纯虚函数的类
* 接口类：仅含有纯虚函数的抽象类
* 聚合类：用户可以直接访问其成员，并且具有特殊的初始化语法形式。满足如下特点：
    * 所有成员都是 public
    * 没有有定于任何构造函数
    * 没有类内初始化
    * 没有基类，也没有 virtual 函数



### 虚表

&emsp;&emsp;C++标准没有规定虚函数的实现方式，只规定了虚函数需要在运行时动态分派函数。虚表是虚函数的主流实现方式，具有比较均衡的性能与用途。

&emsp;&emsp;在简单继承中，编译器会给每个有虚函数的**类**生成一张虚表 (`vtable`)，表内是指向每个虚函数的函数指针。每个类的**对象**会包含一个虚表指针 (`vptr`)，大小固定，虚表指针会指向该类的虚表。调用函数时，程序根据虚表指针指向的虚表来查找虚函数。

<details> <summary> 虚表示例 </summary>

```C++
class Base
{
public:
	virtual void func1() {}
	virtual void func2() {}
};

class Derived1 : public Base
{
public:
	virtual void func1() override {}
};

class Derived2 : public Base
{
public:
	virtual void func2() override {}
};
```
如果将这段代码的虚表显式写出来（Visutal Studio 可以通过 /d1 reportAllClassLayout 命令来查看类的 layout）：

```C++
class Base
{
public:
	virtual void func1() {}
	virtual void func2() {}
private:
	// void **vptr;
	// vptr[0] = Base::func1(void);
	// vptr[1] = Base::func2(void);
};

class Derived1 : public Base
{
public:
	virtual void func1() override {}
private:
	// void **vptr;
	// vptr[0] = Derived::func1(void);
	// vptr[1] = Base::func2(void);
};

class Derived2 : public Base
{
public:
	virtual void func2() override {}
private:
	// void **vptr;
	// vptr[0] = Base::func1(void);
	// vptr[1] = Derived::func2(void);
};
```

</details>

`vtable` :

&emsp;&emsp;虚表存放在编译器指定的位置，虚表的长度和虚函数的个数成正比，每个**类**只有一个虚表。

&emsp;&emsp;基类的虚表内存储的就是基类的函数，子类如果 `override` 了父类的某个函数，则子类虚表的函数指针改为指向子类重写的函数，没有重写的则仍然指向父类的函数。如果子类添加了新的虚函数，则直接在子类虚表中添加新的函数指针。

`vptr`:

&emsp;&emsp;每个类的**对象**会被编译器插入一个虚表指针 `vptr`，这个指针和 `this` 不同，`vptr` 是存在于类对象内存里的，而 `this` 是由编译器管理的。在继承的时候，`vptr` 会自动指向继承类的虚表。
  
&emsp;&emsp;构造的时候，先调用基类构造函数，再调用继承类的构造函数，`vptr`在这个过程中也会指向继承体系中不同类的虚表，析构时也同理。所以不能在构造或析构函数里调用虚函数。

### 多继承与虚继承

假如有这种情况
```C++
class A {};
class B1 : A {};
class B2 : A {};
class C : B1, B2 {};
```
&emsp;&emsp;因为 C 有两棵继承树 A - B1 - C 和 A - B2 - C，所以 C 会有两份 A 的成员变量，并且在构造时会执行两次 A 的构造函数，析构同理。如果这个体系中有虚函数，更是难以处理。

&emsp;&emsp; C++ 为我们提供了虚继承来解决这个问题。

```C++
class A {};
class B1 : virtual A {};
class B2 : virtual A {};
class C : B1, B2 {};
```
&emsp;&emsp;这样编译器就可以避免 C 保存多份 A 的成员变量。C 也只会执行一次 A 的构造与析构函数。

&emsp;&emsp;对于这种 菱形继承 下虚表的情况，各种编译器的实现不一，可能会用到多层虚表，也可能会在继承树足够简单的情况下合并成虚表。具体实现就不再做讨论。

### 虚函数指针、虚函数表

* 虚函数指针：在含有虚函数类的对象中，指向虚函数表，在运行时确定。
* 虚函数表：在程序只读数据段（`.rodata section`，见：[目标文件存储结构](#%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84)），存放虚函数指针，如果派生类实现了基类的某个虚函数，则在虚表中覆盖原本基类的那个虚函数指针，在编译时根据类的声明创建。

### 虚继承

虚继承用于解决多继承条件下的菱形继承问题（浪费存储空间、存在二义性）。

底层实现原理与编译器相关，一般通过**虚基类指针**和**虚基类表**实现，每个虚继承的子类都有一个虚基类指针（占用一个指针的存储空间，4字节）和虚基类表（不占用类对象的存储空间）（需要强调的是，虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了）；当虚继承的子类被当做父类继承时，虚基类指针也会被继承。

实际上，vbptr 指的是虚基类表指针（virtual base table pointer），该指针指向了一个虚基类表（virtual table），虚表中记录了虚基类与本类的偏移地址；通过偏移地址，这样就找到了虚基类成员，而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间。

### 虚继承、虚函数

* 相同之处：都利用了虚指针（均占用类的存储空间）和虚表（均不占用类的存储空间）
* 不同之处：
    * 虚继承
        * 虚基类依旧存在继承类中，只占用存储空间
        * 虚基类表存储的是虚基类相对直接继承类的偏移
    * 虚函数
        * 虚函数不占用存储空间
        * 虚函数表存储的是虚函数地址

























### 类的布局

https://www.cnblogs.com/noryes/p/6434245.html

简单的内存布局原则：成员变量按其被声明的顺序排列，按具体实现所规定的对齐原则在内存地址上对齐。

实际上，只有成员变量才占用类实例的空间 。要注意的是，C++标准委员会不限制由“public/protected/private”关键字分开的各段在实现时的先后顺序，因此，不同的编译器实现的内存布局可能并不相同。（ 在VC++中，成员变量总是按照声明时的顺序排列）。


静态成员，该数据存放在程序的数据段 中，不在类实例中。

类的数据成员按其声明顺序加入内存，（与其访问权限无关，即无论public，private，protected的数据成员，只看其声明顺序）
派生类继承基类的所有成员（包括私有数据成员），派生类的大小是在基类的大小的基础上再增加自己数据成员的空间。


<details><summary>一道结构体与指针的习题</summary>


```cpp

	struct S {
		int i;
		int *p;
	};
	// 结构体中，p在i之后
	int main() {
		S s;
		int *p = &s.i; // p指向i
		p[0] = 4; // p[0]指向s.i，s.i = 4
		p[1] = 3; // p[1] 指向 s.p, s.p = 0x0003
		s.p = p;  // s.p = p, 即s.p 指向 s.i
		s.p[1] = 1; // s.p[1] 指向s.p本身，s.p = 0x0001
		s.p[0] = 2; // 0x0001 = 2，未使用的地址，程序崩溃
	}

```

</details>





### 虚函数的性能与开销

**空间开销**

&emsp;&emsp;每个类多了一个虚表，存放函数指针数组，指针的个数与虚函数个数相同，这些会存放在程序的二进制文件里；每个对象多了一个函数指针 `vptr`，会占用运行时的内存。

> 存储数据较少，需要大量实例化的类，比如 Point，Vector，最好不要有虚函数，否则容量可能会翻倍。

**时间开销**

&emsp;&emsp;通过指针找虚函数表会多了一次或数次内存寻址，看起来不会造成很大的时间开销。如果深入体系结构的话，虚函数本身的机制其实和体系结构是由一定冲突的。

&emsp;&emsp;虚函数的 Cache 命中率不好。一般函数调用后指令可能就在函数地址附近，而虚函数很可能不在 cache 里，需要先在 cache 内载入虚函数表，导致指令和数据 cache 的命中率下降。虽然CPU 会预先预测程序的分支，但预测失败时会清掉整个流水线 (flush) 重来。虚函数内的地址本身就不确定，导致 CPU 预测难度较大，flush 的次数多了，效率也就低了。

&emsp;&emsp;不过，面向对象并不是面向性能，有一定的 tradeoff 是正常的。如果追求性能，需要按照面向数据 (Data Oriented Design) 的思路来设计程序，这又是另一个话题了。

### 多态简介
&emsp;&emsp; 在 C++ 中，虚函数是与多态分不开的，但在程序语言世界里，多态有更广义的解释。

&emsp;&emsp; 多态 (Polymorphism) 是程序语言的一种特性，可以概括为"一个接口，多个方法"。拥有多态性的程序会根据对象的类别来执行不同的动作。

维基百科给多态分了三类：

1. Ad hoc Polymorphism，一个接口，能接受定义过的一些类型，例如 C++ 中的重载
2. Parametric Polymorphism，参数化多态，一个接口，不限定类型，例如 C++ 中的模板
3. Subtype Polymorphism，子类型多态，面向对象中，根据继承关系来确定行为，例如 C++ 中的虚函数

&emsp;&emsp; 面向对象的三件套中，多态的目的是为了**接口重用**，封装是为了代码模块化，继承是为了扩展已存在的代码。其实每一个的实现都有不同的方法，虚函数，类，继承只是接触过最多的。


**静态多态与动态多态** `static` & `dynamic`

&emsp;&emsp; 多态分为静态多态和动态多态，静态与动态分别指的是编译期 (Compile time) 和运行时 (Runtime)。所以也可以称为运行时多态和编译期多态。相应的，变量定义时的类型叫做静态类型，比如基类指针的类型，运行时该指针指向的内容的类型称为动态类型。

&emsp;&emsp;在 C++ 中，静态多态包括 函数重载与运算符重载 (`overload`)，以及泛型编程使用的模板 (`template`)。C++ 的动态多态主要是通过 虚函数 (`virtual`) 实现的。

**静态绑定与动态绑定**

|名字|时间|别名|
| :-: | :-: | :-: |
|静态绑定|编译期|早绑定|
|动态绑定|运行时|晚绑定|

&emsp;&emsp; 每个函数被编译好之后，都是有自己的地址的，函数的参数会与这个地址联系在一起，这个过程叫做绑定 (binding)。一般的函数地址和其参数是在编译时就绑定好了，称作静态绑定。而通过函数指针去调用一个函数，这个函数的地址会在运行时才和变量绑定到一起，这种情况被称作动态绑定，虚函数也是动态绑定的。

&emsp;&emsp;动态绑定需要再通过一个指针去找函数地址，比静态绑定要多一步，会慢一点，但更加的灵活。在某些情况中，函数的声明和定义是分开的，例如在调用库时，只知道函数的声明，函数的具体实现已经被编译成二进制文件了，就只能在运行时进行解析用了哪个函数。这样，函数实现就可以单独更新，可以升级库文件而不更改代码。这就是**动态多态**带来的好处之一。

[返回目录](#Content)