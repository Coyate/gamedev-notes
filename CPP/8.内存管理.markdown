- 手动内存管理
    - new delete, malloc, free
- 自动内存管理
    - 智能指针
- RAII 资源管理


- [手动内存管理](#手动内存管理)
	- [`new` & `delete`](#new--delete)
		- [`placement` new](#placement-new)
		- [delete this 合法吗？](#delete-this-合法吗)
	- [`<allocator>`](#allocator)
	- [`malloc` & `free`](#malloc--free)
		- [malloc 与 new 的区别](#malloc-与-new-的区别)
	- [`alloc`](#alloc)
		- [如何定义一个只能在堆上（栈上）生成对象的类？](#如何定义一个只能在堆上栈上生成对象的类)
- [智能指针](#智能指针)
		- [shared_ptr](#shared_ptr)
		- [weak_ptr](#weak_ptr)
		- [unique_ptr](#unique_ptr)
- [RAII 资源获取即初始化](#raii-资源获取即初始化)
	- [拷贝控制](#拷贝控制)


### 手动内存管理

https://www.cnblogs.com/maluning/p/7944231.html
https://www.cnblogs.com/iloverain/p/5633281.html
https://blog.csdn.net/qq_33573235/article/details/79485266
https://blog.csdn.net/l_xrui/article/details/62886695

使用动态生存周期的理由
	1. 程序不知道自己需要使用多少对象
	2. 程序不知道所需对象的类型
	3. 程序需要在多个对象间共享数据
	4. 
#### `new` & `delete`


直接管理内存 new & delete
new构造一个对象，并返回一个指针
	• 动态分配的对象是默认初始化的
	int *pi = new int;
	string *pi = new string;
	• 也使用直接初始化方式来初始化
	int *pi = new int(1024);
	string *ps = new string(10, '9');
	• 也可以使用值初始化
	int *pi = new int();
	string *ps = new string();
	• 使用auto来动态推断
	auto p1 = new auto(obj);
	• 创建动态分配的const对象必须初始化
	const string *pcs =  new const string;
	• 当内存耗尽时,new会抛出bad_alloc异常
	• 通过使用定位new (placement new)可以避免异常
	int *p2 = new (nothrow) int; // 如果没空间则返回空指针
	
delete接受一个动态分配的对象或者空指针，销毁指针指向的对象，并释放内存
	• 释放非new分配的内存或者多次释放的行为是未定义的
	• 释放了一块内存后需要将指针置为空，否则指针就变成了空悬指针 (dangling pointer)

动态数组
new T[ ] 分配一个动态数组，返回一个数组元素类型的指针 
	int  *pia = new int[size]; // 未初始化
	using arrT = int[42];
	int *p = new arrT;
	• 无法用begin, end
	• 无法对其使用range for
	• 可以分配size为0的数a组，new 返回一个合法的非空指针，该指针不能解引用
	char *cp = new char[0]; 

初始化
	int *pis2 = new int[10](); // 值初始化为0
	int *pis3 = new int[10]{1, 2, 3, 4, 5, 6}; // 列表初始化，剩下的值初始化
	
释放动态数组
delete [ ] p; // 如果忘掉 [ ], 则行为未定义

 new [] 一个对象数组时，需要保存数组的维度，C++ 的做法是在分配数组空间时多分配了 4 个字节的大小，专门保存数组的大小，在 delete [] 时就可以取出这个保存的数，就知道了需要调用析构函数多少次了。
 那么 delete pAa; 做了两件事：

调用一次 pAa 指向的对象的析构函数；调用 operator
 delete(pAa); 释放内存。内嵌类型不需要调用析构函数，所以能成功

显然，这里只对数组的第一个类对象调用了析构函数，后面的两个对象均没调用析构函数，如果类对象中申请了大量的内存需要在析构函数中释放，而你却在销毁数组对象时少调用了析构函数，这会造成内存泄漏。

https://blog.csdn.net/cwcmcw/article/details/53873600
特性	malloc/free	new/delete
非内部数据类型的构造和析构	库函数，无法支持构造与析构	支持

1. new / new[]：完成两件事，先底层调用 malloc 分了配内存，然后调用构造函数（创建对象）。
2. delete/delete[]：也完成两件事，先调用析构函数（清理资源），然后底层调用 free 释放空间。
3. new 在申请内存时会自动计算所需字节数，而 malloc 则需我们自己输入申请内存空间的字节数。

<details><summary>new、delete 使用</summary> 

申请内存，确认是否申请成功

```cpp
int main()
{
    T* t = new T();     // 先内存分配 ，再构造函数
    delete t;           // 先析构函数，再内存释放
    return 0;
}
```

</details>

##### `placement` new

&emsp;&emsp;new 表达式/运算符, 先执行 operator new 获取内存空间，再执行构造

1. operator new 标准库函数
   operator new 重载是全局的...从此就靠这个来分配内存，所以一定要保证正确性
   也可以给类定义自己的 operator new，会自动变为 隐式静态，无需 static，因为其用来对象构造之前或析构之后
   必须返回 void *, 第一个实参必须是 size_t，不能有默认实参

   可以使用作用域运算符显式查找 ::new
	void *operator new[](size_t);
	void *operator new[](size_t, nothrow_t&) noexcept;
	#include <new> 里有一个 std::nothrow 可以请求无异常版本的 new
	重载的时候也必须保证没有异常

	void *operator new(size_t, void*) 不允许重载，只能标准库使用

	operator delete 必须返回 void, 第一个实参必须是 void*
	在类中重载 operator delete 时，可以包含一个 size_t 形参，该形参的初始值是 void* 指向的对象的字节数


```C++ 
void *opeartor new(size_t size) {
	if(void *mem = malloc(size))
		return mem;
	else
		throw bad_alloc();
}
void operator delete(void * mem) noexcept {
	free(mem);
}
```
3. placement new 
	int *p = new (nothrow) int; // 失败返回空指针
	new (place_address) type;
	new (place_address) type (initializers);
	new (place_address) type [size];
	new (place_address) type [size] {braced initializer list};
https://www.cnblogs.com/slgkaifa/p/6887887.html
https://blog.csdn.net/weixin_38739799/article/details/80763593
http://lib.csdn.net/article/cplusplus/23820
https://www.cnblogs.com/Chierush/p/3744131.html

https://blog.csdn.net/silangquan/article/details/18013967

什么是displacement new？

placement new是重载operator new的一个标准、全局的版本，它不能被自定义的版本代替（不像普通的operator new和operator delete能够被替换成用户自定义的版本）。

它的原型如下：
void *operator new( size_t, void *p ) throw() { return p; }

首先我们区分下几个容易混淆的关键词：new、operator new、placement new

new和delete操作符我们应该都用过，它们是对堆中的内存进行申请和释放，而这两个都是不能被重载的。要实现不同的内存分配行为，需要重载operator new，而不是new和delete。

看如下代码：
class MyClass {…};
MyClass * p=new MyClass;

这里的new实际上是执行如下3个过程：
1调用operator new分配内存；
2调用构造函数生成类对象；
3返回相应指针。

operator new就像operator+一样，是可以重载的，但是不能在全局对原型为void operator new(size_t size)这个原型进行重载，一般只能在类中进行重载。如果类中没有重载operator new，那么调用的就是全局的::operator new来完成堆的分配。同理，operator new[]、operator delete、operator delete[]也是可以重载的，一般你重载了其中一个，那么最好把其余三个都重载一遍。

placement new是operator new的一个重载版本，只是我们很少用到它。如果你想在已经分配的内存中创建一个对象，使用new是不行的。也就是说placement new允许你在一个已经分配好的内存中（栈或堆中）构造一个新的对象。原型中void*p实际上就是指向一个已经分配好的内存缓冲区的的首地址。

我们知道使用new操作符分配内存需要在堆中查找足够大的剩余空间，这个操作速度是很慢的，而且有可能出现无法分配内存的异常（空间不够）。placement new就可以解决这个问题。我们构造对象都是在一个预先准备好了的内存缓冲区中进行，不需要查找内存，内存分配的时间是常数；而且不会出现在程序运行中途出现内存不足的异常。所以，placement new非常适合那些对时间要求比较高，长时间运行不希望被打断的应用程序。

使用方法如下：

1. 缓冲区提前分配
可以使用堆的空间，也可以使用栈的空间，所以分配方式有如下两种：
class MyClass {…}; 
char *buf=new char[N*sizeof(MyClass)+ sizeof(int) ] ; 或者char buf[N*sizeof(MyClass)+ sizeof(int) ];
2. 对象的构造
MyClass * pClass=new(buf) MyClass;
3. 对象的销毁
一旦这个对象使用完毕，你必须显式的调用类的析构函数进行销毁对象。但此时内存空间不会被释放，以便其他的对象的构造。
pClass->~MyClass();
4. 内存的释放
如果缓冲区在堆中，那么调用delete[] buf;进行内存的释放；如果在栈中，那么在其作用域内有效，跳出作用域，内存自动释放。

注意：
1) 在C++标准中，对于placement operator new []有如下的说明： placement operator new[] needs implementation-defined amount of additional storage to save a size of array. 所以我们必须申请比原始对象大小多出sizeof(int)个字节来存放对象的个数，或者说数组的大小。
2) 使用方法第二步中的new才是placement new，其实是没有申请内存的，只是调用了构造函数，返回一个指向已经分配好的内存的一个指针，所以对象销毁的时候不需要调用delete释放空间，但必须调用析构函数销毁对象。




定位 new（placement new）允许我们向 new 传递额外的参数。

```cpp
new (palce_address) type
new (palce_address) type (initializers)
new (palce_address) type [size]
new (palce_address) type [size] { braced initializer list }
```

* `palce_address` 是个指针
* `initializers` 提供一个（可能为空的）以逗号分隔的初始值列表



##### delete this 合法吗？

[Is it legal (and moral) for a member function to say delete this?](https://isocpp.org/wiki/faq/freestore-mgmt#delete-this)

合法，但：

1. 必须保证 this 对象是通过 `new`（不是 `new[]`、不是 placement new、不是栈上、不是全局、不是其他对象成员）分配的
2. 必须保证调用 `delete this` 的成员函数是最后一个调用 this 的成员函数
3. 必须保证成员函数的 `delete this ` 后面没有调用 this 了
4. 必须保证 `delete this` 后没有人使用了





##### 为何delete操作不把指针置零？
A: 嗯，问得挺有道理的。我们来看：
	delete p;
	// ...
	delete p;
 
如果代码中的//...部分没有再次给p分配内存，那么这段代码就对同一片内存释放了两次。这是个严重的错误，可惜C++无法有效地阻止你写这种代码。不过，我们都知道，释放空指针是无危害的，所以如果在每一个delete p;后面都紧接一个p = 0;，那么两次释放同一片内存的错误就不会发生了。尽管如此，在C++中没有任何语法可以强制程序员在释放指针后立刻将该指针归零。所以，看来避免犯这样的错误的重任只能全落在程序员肩上了。或许，delete自动把指针归零真是个好主意？
哦，不不，这个主意不够“好”。一个理由是，被delete的指针未必是左值。我们来看：

	delete p+1;
	delete f(x);
 
你让delete把什么自动置零？也许这样的例子不常见，但足可证明“delete自动把指针归零”并不保险。[译注：事实上，我们真正想要的是：“任何指向被释放的内存区域的指针都被自动归零”——但可惜除了Garbage Collector外没什么东东可以做到这点。] 再来看个简单例子：
	T* p = new T;
	T* q = p;
	delete p;
	delete q;	// ouch!
 
C++标准其实允许编译器实作为“自动把传给delete的左值置零”，我也希望编译器厂商这样做，但看来厂商们并不喜欢这样。一个理由就是上述例子——第3行语句如果delete把p自动置零了又如何呢？q又没有被自动置零，第4行照样出错。
如果你觉得释放内存时把指针置零很重要，那么不妨写这样一个destroy函数：

	template<class T> inline void destroy(T*& p) { delete p; p = 0; }
不妨把delete带来的麻烦看作“尽量少用new/delete，多用标准库中的容器”之另一条理由吧 :O)

请注意，把指针作为引用传递（以便delete可以把指针置零）会带来额外的效益——防止右值被传递给destroy() ：

	int* f();
	int* p;
	// ...
	destroy(f());	// error: trying to pass an rvalue by non-const reference
	destroy(p+1);	// error: trying to pass an rvalue by non-const reference



#### `<allocator>`
<allocator>
allocator<T> a	allocator<string> alloc;
a.allocate(n)	分配一段原始的，未构造的内存，可以保存n个类型为string的对象
a.deallocate(p, n)	释放(T*)p指向的内存，p必须是之前由allocate返回的指针，且n是其申请的大小
a.construct(p, args)	在p指向的位置用构造函数构造对象
a.destroy(p)	对p指向的对象执行析构函数
	• 未构造的原始内存不能使用

uninitialized_copy(b, e, b2)	拷贝元素到b2所值得原始内存中，b2的容量要大于b到e
uninitialized_copy_n(b, n, b2)	从b拷贝n个元素到b2
uninitialized_fill(b, e, t)	在b和e指定的范围构造对象，对象的值均为t
uninitialized_fill_n(b, n, t)	在b开始的范围填充10个t

#### `malloc` & `free`
&emsp;&emsp;<cstdlib>

用于分配、释放内存

<details><summary>malloc、free 使用</summary> 

申请内存，确认是否申请成功

```cpp
char *str = (char*) malloc(100);
assert(str != nullptr);
```

释放内存后指针置空

```cpp
free(p); 
p = nullptr;
```

</details>


new 或者malloc最多能申请多大的内存？

32位程序不可能申请大于4G的内存,linux在X86系统下，理论上用户态可以申请3G内存（有1G的地址空间留给内核），内核态可以申请4G内存，windows你需要查一查其系统规范。



linux下用top命令显示有内存空间，但malloc一个64mbuffer的时候失败了，什么原因，为啥会出现这种情况？试着malloc一个1m的buffer可能成功么？

内存碎片，无法找出连续的地址空间。空闲内存以小而不连续方式出现在不同的位置。由于分配方法决定内存碎片是否是一个问题，因此内存分配器在保证空闲资源可用性方面扮演着重要的角色。

内存碎片存在的方式有两种：a.内部碎片 b.外部碎片 。
内部碎片的产生：因为所有的内存分配必须起始于可被 4、8 或 16 整除（视处理器体系结构而定）的地址或者因为MMU的分页机制的限制，决定内存分配算法仅能把预定大小的内存块分配给客户。假设当某个客户请求一个 43 字节的内存块时，因为没有适合大小的内存，所以它可能会获得 44字节、48字节等稍大一点的字节，因此由所需大小四舍五入而产生的多余空间就叫内部碎片。
外部碎片的产生： 频繁的分配与回收物理页面会导致大量的、连续且小的页面块夹杂在已分配的页面中间，就会产生外部碎片。假设有一块一共有100个单位的连续空闲内存空间，范围是0~99。如果你从中申请一块内存，如10个单位，那么申请出来的内存块就为0~9区间。这时候你继续申请一块内存，比如说5个单位大，第二块得到的内存块就应该为10~14区间。如果你把第一块内存块释放，然后再申请一块大于10个单位的内存块，比如说20个单位。因为刚被释放的内存块不能满足新的请求，所以只能从15开始分配出20个单位的内存块。现在整个内存空间的状态是0~9空闲，10~14被占用，15~24被占用，25~99空闲。其中0~9就是一个内存碎片了。如果10~14一直被占用，而以后申请的空间都大于10个单位，那么0~9就永远用不上了，变成外部碎片。

可能会成功。

##### malloc 与 new 的区别

a.属性

　　new/delete是C++关键字，需要编译器支持。malloc/free是库函数，需要头文件支持c。

b.参数

　　使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。而malloc则需要显式地指出所需内存的尺寸。

c.返回类型

　　new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。

e. 分配失败

　　new内存分配失败时，会抛出bac_alloc异常。malloc分配内存失败时返回NULL。

f.自定义类型

         new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）。

         malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。

g.重载

　　C++允许重载new/delete操作符，特别的，布局new的就不需要为对象分配内存，而是指定了一个地址作为内存起始区域，new在这段内存上为对象调用构造函数完成初始化工作，并返回此地址。而malloc不允许重载。

h.内存区域

　　new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。自由存储区不等于堆，如上所述，布局new就可以不位于堆中。


#### `alloc`

1. malloc：申请指定字节数的内存。申请到的内存中的初始值不确定。
2. calloc：为指定长度的对象，分配能容纳其指定个数的内存。申请到的内存的每一位（bit）都初始化为 0。
3. realloc：更改以前分配的内存长度（增加或减少）。当增加长度时，可能需将以前分配区的内容移到另一个足够大的区域，而新增区域内的初始值则不确定。
4. alloca：在栈上申请内存。程序在出栈的时候，会自动释放内存。但是需要注意的是，alloca 不具可移植性, 而且在没有传统堆栈的机器上很难实现。alloca 不宜使用在必须广泛移植的程序中。C99 中支持变长数组 (VLA)，可以用来替代 alloca。



VirtualAlloc，进程地址空间内存，速度块，灵活？
https://www.cnblogs.com/arsense/p/6505690.html



##### 如何定义一个只能在堆上（栈上）生成对象的类？

[如何定义一个只能在堆上（栈上）生成对象的类?](https://www.nowcoder.com/questionTerminal/0a584aa13f804f3ea72b442a065a7618)

只能在堆上

方法：将析构函数设置为私有

原因：C++ 是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象。

只能在栈上

方法：将 new 和 delete 重载为私有

原因：在堆上生成对象，使用 new 关键词操作，其过程分为两阶段：第一阶段，使用 new 在堆上寻找可用内存，分配给对象；第二阶段，调用构造函数生成对象。将 new 操作设置为私有，那么第一阶段就无法完成，就不能够在堆上生成对象。


https://blog.csdn.net/u010536615/article/details/45337841
https://blog.csdn.net/wonengxing/article/details/6862971
class A  
{  
public:  
    A(){}  
    void destory(){delete this;}  
private:  
    ~A(){}  
};  

试着使用A a;来建立对象，编译报错，提示析构函数无法访问。这样就只能使用new操作符来建立对象，构造函数是公有的，可以直接调用。类中必须提供一个destory函数，来进行内存空间的释放。类对象使用完成后，必须调用destory函数。
        上述方法的一个缺点就是，无法解决继承问题。如果A作为其它类的基类，则析构函数通常要设为virtual，然后在子类重写，以实现多态。因此析构函数不能设为private。还好C++提供了第三种访问控制，protected。将析构函数设为protected可以有效解决这个问题，类外无法访问protected成员，子类则可以访问。

        另一个问题是，类的使用很不方便，使用new建立对象，却使用destory函数释放对象，而不是使用delete。（使用delete会报错，因为delete对象的指针，会调用对象的析构函数，而析构函数类外不可访问）这种使用方式比较怪异
析构函数设为private







### 智能指针




http://www.cnblogs.com/lanxuezaipiao/p/4132096.html

https://blog.csdn.net/zy19940906/article/details/50470087
https://www.jb51.net/article/90044.htm
https://www.cnblogs.com/wxquare/p/4759020.html
https://blog.csdn.net/icandoit_2014/article/details/56666277

智能指针通用操作 <memory >
shared_ptr<T> sp	空指针，指向类型为T的对象
unique_ptr<T> up
p	是否为空
*p	解引用，获得对象
p.get()	返回p中保留的普通指针（释放之后无效的普通指针）
	不影响引用计数   

https://www.zhihu.com/question/285728913/answer/445461863

shared_ptr
shared_ptr是一种智能指针，允许多个指针指向一个对象
	• shared_ptr有个引用计数，拷贝shared_ptr会递增引用计数
	• shared_ptr的析构函数会递减其引用计数，当引用计数为0时，销毁对象，释放对应内存
	• 在容器中shared_ptr不需要时或被析构了，需要erase掉

基本操作
make_shared<T>(args)	分配内存并用args初始化对象，并返回该对象的shared_ptr
p = q	让p指向q指向的对象，递减p的计数，递增q的计数
p.unique()	p的引用计数是否为1
p.use_count()	返回引用计数

指针转换
shared_ptr<T> p(q) 	内置指针转化为shared_ptr
shared_ptr<T> p(q, d)	d是一个可调用对象，作为delete使用
	shared_ptr<int> p2(new int(1024));
	shared_ptr<connection> p(&c, end_connection);
shared_ptr<T> p(u)	从unique_ptr接管，u被置为空
shared_ptr<T> p(p2)	拷贝一个shared_ptr，递增p中的计数器，p2的指针必须要能转换为T
shared_ptr<T> p(p2, d)
p.reset()	若p是唯一指向对象的shared_ptr，reset会调用delete(或者d)释放掉此对象，并将p置为空（或者置为q）
p.reset(q)	
p.reset(q, d)
	

	• 不要混用普通指针和智能指针
	• 不要使用get()初始化一个智能指针或为智能指针赋值
	• 不使用相同的内置指针初始化（或reset）多个智能指针
	• 不delete get()返回的指针
	• 若管理的对象不是由new分配的内存，则需要传递一个删除器给shared_ptr
	
错误示范
	1. process(shared_ptr<int>(p.get()));
	在process内生成了新的，引用计数为1的shared_ptr，在函数结束时引用计数减少为0，释放了p.get()取得的指针指向的空间
	2. auto sp = make_shared<int>();
	auto p = sp.get();
	delete p;
	未减少sp的引用计数，sp引用计数归零时会再度进行delete


unique_ptr
某个时刻只能有一个unique_ptr指向一个给定对象


unique_ptr<T> u1;	unique_ptr<double> p1; 
unique_ptr<T, D> u2;	unique_ptr<int> p2(new int(42));
unique_ptr<T, D> u(d);	定义时需要将其绑定到一个new返回的指针上
	绑定d来代替delete
unique_ptr<string> p2(p1);	不能拷贝与赋值
unique_ptr<string> p3 = p2;
u = nullptr;	释放u指向的对象，将u置为空
u.release()	放弃对指针的控制权，返回指针，将u置为空
u.reset()	释放对象，令u指向空或者q
u.reset(q)
u.reset(nullptr)
u.reset(u2.release())	转移所有权
auto p = p2.release();	危险操作，不推荐
delete p;

用unique_ptr来管理动态数组
	unique_ptr<int[]> up(new int [10]);
	up.release(); // 自动使用delete []
	up[i]; // 返回第i个位置上的对象
	
用shared_ptr来管理动态数组
	必须提供删除器
	shared_ptr<int> sp(new int[10], [ ](int *p) { delete[] p;});
	sp.reset();
	*(sp.get() + i) = i;

weak_ptr
不控制对象生存周期，指向一个shared_ptr管理的对象，不改变shared_ptr的引用计数
weak_ptr<T> w	传入shared_ptr
weak_ptr<T> w(sp)
w = p	赋值后w与p共享对象
w.reset( )	将w置为空
w.use_count( )	引用计数
w.expired( )	如果引用计数为0，返回true，否则返回false
w.lock( )	如果引用计数为0，则返回一个空shared_ptr，否则返回一个指向w的对象的shared_ptr

解除循环引用




`#include <memory>`


1. shared_ptr
2. unique_ptr
3. weak_ptr

* Class shared_ptr 实现共享式拥有（shared ownership）概念。多个智能指针指向相同对象，该对象和其相关资源会在 “最后一个 reference 被销毁” 时被释放。为了在结构较复杂的情景中执行上述工作，标准库提供 weak_ptr、bad_weak_ptr 和 enable_shared_from_this 等辅助类。
* Class unique_ptr 实现独占式拥有（exclusive ownership）或严格拥有（strict ownership）概念，保证同一时间内只有一个智能指针可以指向该对象。你可以移交拥有权。它对于避免内存泄漏（resource leak）——如 new 后忘记 delete ——特别有用。

##### shared_ptr

多个智能指针可以共享同一个对象，对象的最末一个拥有着有责任销毁对象，并清理与该对象相关的所有资源。

* 支持定制型删除器（custom deleter），可防范 Cross-DLL 问题（对象在动态链接库（DLL）中被 new 创建，却在另一个 DLL 内被 delete 销毁）、自动解除互斥锁

##### weak_ptr

weak_ptr 允许你共享但不拥有某对象，一旦最末一个拥有该对象的智能指针失去了所有权，任何 weak_ptr 都会自动成空（empty）。因此，在 default 和 copy 构造函数之外，weak_ptr 只提供 “接受一个 shared_ptr” 的构造函数。

* 可打破环状引用（cycles of references，两个其实已经没有被使用的对象彼此互指，使之看似还在 “被使用” 的状态）的问题

##### unique_ptr

unique_ptr 是 C++11 才开始提供的类型，是一种在异常时可以帮助避免资源泄漏的智能指针。采用独占式拥有，意味着可以确保一个对象和其相应的资源同一时间只被一个 pointer 拥有。一旦拥有着被销毁或编程 empty，或开始拥有另一个对象，先前拥有的那个对象就会被销毁，其任何相应资源亦会被释放。

unqiue_ptr 无拷贝赋值语义，但实现了`move` 语义；
move语义


### RAII 资源获取即初始化

Q: 为何C++不提供“finally”结构？
A: 因为C++提供了另一种机制，完全可以取代finally，而且这种机制几乎总要比finally工作得更好：就是——“分配资源即初始化”。（见《The C++ Programming Language》14.4节）基本的想法是，用一个局部对象来封装一个资源，这样一来局部对象的析构函数就可以自动释放资源。这样，程序员就不会“忘记释放资源”了。 [译注：因为C++的对象“生命周期”机制替他记住了 :O) ] 下面是一个例子：
	class File_handle {
		FILE* p;
	public:
		File_handle(const char* n, const char* a)
			{ p = fopen(n,a); if (p==0) throw Open_error(errno); }
		File_handle(FILE* pp)
			{ p = pp; if (p==0) throw Open_error(errno); }

		~File_handle() { fclose(p); }

		operator FILE*() { return p; }

		// ...
	};

	void f(const char* fn)
	{
		File_handle f(fn,"rw");	// open fn for reading and writing
		// use file through f
	}
 
在一个系统中，每一样资源都需要一个“资源局柄”对象，但我们不必为每一个资源都写一个“finally”语句。在实作的系统中，资源的获取和释放的次数远远多于资源的种类，所以“资源分配即初始化”机制产生的代码要比“finally”机制少。
 
[译注：Object Pascal，Java，C#等语言都有finally语句块，常用于发生异常时对被分配资源的资源的处理——这意味着有多少次分配资源就有多少finally语句块（少了一个finally就意味着有一些资源分配不是“exception safe”的）；而“资源分配即初始化”机制将原本放在finally块中的代码移到了类的析构函数中。我们只需为每一类资源提供一个封装类即可。需代码量孰多孰少？除非你的系统中每一类资源都只被使用一次——这种情况下代码量是相等的；否则永远是前者多于后者 :O) ]
另外，请看看《The C++ Programming Language》附录E中的资源管理例子。



#### 移动

##### 左值与右值
https://www.cnblogs.com/zhangdongsheng/p/7664228.html
https://www.cnblogs.com/zpcdbky/p/5275959.html

&emsp;&emsp;左值和右值是表达式的属性， lvalue & rvalue（读作 l-value, r-value）。简单来说，左值是可以被赋值的对象，而右值只是一个值。

左值	lvalue	持久	用的是对象的身份（在内存中的位置）
右值	rvalue	短暂	用的是对象的值（内存中的内容）

	• 赋值运算符左侧为一个非常量左值
	• 取地址运算符作用于左值对象，返回一个指向该对象的指针，该指针是右值
	• 递增递减运算符作用于左值，前置时返回左值，后置时返回右值

右值引用 rvalue Reference
	• 通过&&获得右值引用，只能绑定到右值
	• 右值引用是一个变量，变量是右值
	int &&rr1 = 42;
	int &&rr2 = rr1;
	• 所引用的对象将要被销毁，该对象没有其他用户
	

&, &&, this 可以指向左值或右值
同名函数，加上不同的引用限定符算作不同函数

 引用折叠

* `X& &`、`X& &&`、`X&& &` 可折叠成 `X&`
* `X&& &&` 可折叠成 `X&&`

左值常规引用，一般表示对象的身份。

右值引用就是必须绑定到右值（一个临时对象、将要销毁的对象）的引用，一般表示对象的值。

右值引用可实现转移语义（Move Sementics）和精确传递（Perfect Forwarding），它的主要目的有两个方面：

* 消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。
* 能够更简洁明确地定义泛型函数。