---
layout: post
title: "标准模板库 STL"
date: 2018-09-07 16:53:59
update: 2018-10-25 16:59:13
categories: C++
img:
---

&emsp;&emsp;STL (Standard Template Library) 标准模板库是 C++ 的内置库，提供了一系列常用的数据结构与算法，而且在使用的时候无需手动管理内存。这篇文章会先介绍 STL 的各个部件与设计思路，然后总结各种容器的基本性质和底层实现。

- [STL 简介](#stl-简介)
    - [STL 内存管理](#stl-内存管理)
- [STL容器基本性质表](#stl容器基本性质表)
- [STL容器介绍](#stl容器介绍)
    - [连续内存顺序容器](#连续内存顺序容器)
        - [vector](#vector)
        - [string](#string)
        - [priority_queue](#priority_queue)
    - [半连续内存顺序容器](#半连续内存顺序容器)
        - [deque](#deque)
        - [stack & queue](#stack--queue)
    - [非连续内存顺序容器](#非连续内存顺序容器)
        - [list & forward_list](#list--forward_list)
    - [有序关联容器](#有序关联容器)
        - [set](#set)
        - [map](#map)
        - [红黑树](#红黑树)
        - [红黑树与哈希表对比](#红黑树与哈希表对比)
    - [无序关联容器](#无序关联容器)
- [应用场合](#应用场合)
    - [迭代器失效](#迭代器失效)
- [STL 库](#stl-库)
    - [algorithm库](#algorithm库)
    - [IO库](#io库)
    - [Fstream库](#fstream库)
    - [`<sstream>`](#sstream)
    - [`<utility>`](#utility)
        - [std::pair](#stdpair)
        - [std::tuple](#stdtuple)
    - [`<array>`](#array)
    - [`<random>`](#random)
    - [正则表达式 `<regex>`](#正则表达式-regex)
    - [位 `<bitset>`](#位-bitset)
    - [替用运算符 `<ciso646>`](#替用运算符-ciso646)

### STL 简介

&emsp;&emsp;STL 有六大组件：容器，算法，迭代器，防函数，配接器，配置器。STL 的核心是泛型容器和算法，可以方便地储存和操作各种类型。STL 组件耦合度低，复用性高。 

1. 容器 (Container) : 常用的数据结构，如 vector, list, deque, set, map 等，用来存放数据。
2. 算法 (Algorithm) : 常用的算法，如 sort, find, remove 等，支持各种容器类型。
3. 迭代器 (Iterator) : 是一种“泛型指针”，可以在各种类型上做类指针的操作。
4. 仿函数 (Functor) : 统一的可调用对象，可以传入泛型算法中作为策略使用。
5. 配接器 (Adapter) : 用来修饰容器，使容器表现出另一种行为，例如 queue, stack, 底层实际是 deque。
6. 配置器 (Allocator) : 负责空间配置与管理，自动管理容器所使用的空间。

#### STL 内存管理

&emsp;&emsp;STL 对象的内存管理由 std::allocator<T> 负责，会自动进行容器内对象构造前的内存申请与析构后的内存释放。STL 内存管理的思路如下：

1. 考虑了多线程状态
2. 内存不足时自动向 system heap 要空间
3. 考虑了内存碎片问题

&emsp;&emsp;其中，内存碎片是通过双层级配置器来解决的。如果申请的内存大于 128 字节，那么通过第一层配置器直接向系统申请。如果小于 128 字节，则交给第二级配置器。第二级配置器管理了一个 free-list，通过这个 free-list 管理了一个小区块内存池。

### STL容器基本性质表

顺序容器及适配器
|容器|性质|访问|查找|插入|删除|其他|
| :-: | - | - | - | - | - | :-: |
|vector|可变数组|随机访问|O(1)|O(n)|O(n)|尾部插入删除O(1)
|string|字符可变数组|随机访问|O(1)|O(n)|O(n)|尾部插入删除O(1)
|priority_queue|堆|O(logn)|O(logn)|O(nlogn)|O(nlogn)|排序队列
|list|双向链表|双向顺序访问|O(n)|O(n)|O(n)|插入/删除比较灵活
|forward_list|单向链表|单向顺序访问|O(n)|O(n)|O(n)|插入/删除灵活
|deque|双端队列|**随机访问**|O(1)|O(n)|O(n)|头尾插入删除O(1)
|queue|单端队列|随机访问|O(1)|O(n)|O(n)|尾部插入删除O(1)
|stack|栈|随机访问|O(1)|O(n)|O(n)|
|array|固定大小数组|随机访问|O(1)|-|-|不能插入/删除



关联容器
|容器|性质|访问|查找|插入|删除|其他|
| :-: | - | - | - | - | - | :-: |
|map|有序字典|O(logn)|O(logn)|O(logn)|O(logn)|
|set|有序集合|O(logn)|O(logn)|O(logn)|O(logn)
|multimap|有序字典|O(logn)|O(logn)|O(logn)|O(logn)|可重复
|multiset|有序集合|O(logn)|O(logn)|O(logn)|O(logn)|可重复
|unordered_map|无序字典|O(1)|O(1)|O(1)|O(1)|
|unordered_set|无序集合|O(1)|O(1)|O(1)|O(1)|
|unordered_multimap|无序字典|O(1)|O(1)|O(1)|O(1)|可重复
|unordered_multiset|无序集合|O(1)|O(1)|O(1)|O(1)|可重复

### STL容器介绍

#### 连续内存顺序容器
##### vector

&emsp;&emsp;vector是可变大小的数组，允许插入和删除，是在 C++ 里经常用来代替 C 数组的一种容器，支持快速随机访问。

&emsp;&emsp;vector 自行维护了一段内存，当插入时内存不够时，会重新申请一段更大的内存，并把目前的数据移动到新内存里，再进行插入。不同编译器的扩容倍数不一样，有 1.5 倍或 2 倍的，1.5倍造成的内存碎片更少。
	       
##### string 
&emsp;&emsp;string 的底层就是 `vector<char>`，但 string 本身还提供了许多字符串操作函数，比如`append`, `substr`, `replace`, `find`, `compare`, `to_string`, `stoi`等。

##### priority_queue
&emsp;&emsp;priority_queue 是优先队列，放入其中的元素会自动排序，一般都是做最大堆/最小堆使用的，STL 提供了 `push`, `pop`, `top` 三种基本操作。

&emsp;&emsp;priority_queue 是一种适配器，是对 vector 容器的再封装。priority_queue 以 vector 为底层容器，使用堆 heap 作为处理规则。

#### 半连续内存顺序容器
##### deque

&emsp;&emsp;deque 是双端队列，可以从首尾快速增删，**也支持用下标随机访问元素**，并不是完全封装的队列，提供了很大的方便。

&emsp;&emsp;deque 的底层是一小块连续空间，该空间每个元素都是指向另一段连续内存的指针，相当于 deque 管理的是一段内存映射表。所以，访问 deque 的元素需要经过两次查找，访问速度要比vector慢。

##### stack & queue

&emsp;&emsp;stack 是栈，queue 是单端队列。

&emsp;&emsp;stack 和 queue 都是适配器，它们的底层一般是 deque。不用 vector 作为底层的原因可能是因为扩容比较耗时。

#### 非连续内存顺序容器
##### list & forward_list

&emsp;&emsp;list 是双向链表，forward_list 是单向链表，两者的底层也是链表，可以快速增删。

&emsp;&emsp;list 的插入，删除，迭代器都和连续内存容器不一样，`lst.before_begin()`, `lst.insert_after()`, `lst.erase_after()`。另外，`<algorithm>` 的泛型算法对 list 不适用。list 有专用版本，例如：`lst.merge`, `lst.sort`, `lst.remove`, `lst.reverse`,`lst.unique`, `lst.splice` 等。

#### 有序关联容器
##### set

&emsp;&emsp; set 是集合，有序排列，默认从小到大，不允许重复的关键字。不允许用下标访问，只能用迭代器直接访问元素。

&emsp;&emsp;multiset 是允许重复关键字的 set。STL 还为 set 提供了一些集合运算的函数，如交集`set_intersection`、并集`set_union`、差集`set_difference`等。

##### map

&emsp;&emsp;map 是字典，存储的为 `{key, value}` 对，可以通过关键字来查找值。map 可以通过下标运算符来建立元素，例如 `m[3]++;`，若之前不存在 key 为 3 的元素，则这条语句会直接创建 key 为 3 的元素，再自增其 value。

&emsp;&emsp;有序关联容器都具有`equal_range`, `lower_bound`, `upper_bound`, `merge`, `count` 等自带算法。

##### 红黑树

&emsp;&emsp;有序关联容器的内部结构都是红黑树 (Red Black Tree, RB-tree)。

&emsp;&emsp;红黑树是一种二叉查找树，也是一种平衡二叉树。红黑是可以用 O(logn) 的时间复杂度进行查找，插入，删除操作。红黑树是统计性能较高的平衡二叉树，被广泛应用于存储有序数据的场景。

&emsp;&emsp;红黑树的平衡并不严格，其只要求树的最长路径不大于两倍最短路径的长度，但这也比 BST 好很多，可以保证 O(logn) 的复杂度，不会像 BST 可能退化到 O(n)。

&emsp;&emsp;红黑树的不平衡在 3 次旋转之内就可以回归平衡，这让它的统计性能比 AVL 树更高。


##### 红黑树与哈希表对比

1. 红黑树有序，hash 表无序
2. hash 表查找速度比红黑树快，复杂度为是 O(1) ，但 hash 表会在 hash 函数上消耗时间，数据量小时，hash 表不一定比红黑树快。而当 hash 表的数据量极大时，可能会因为 hash 函数的质量导致插入/查找元素的时间低于红黑树。
3. hash 表可能会消耗多余的内存，而红黑树不会。
4. 如果数据是静态的，可以使用红黑树，如果数据是动态的，红黑树具有更好的统计性能。


#### 无序关联容器

&emsp;&emsp;无序关联容器有四种，unordered_set，unordered_map，unordered_multiset，unordered_multimap。

&emsp;&emsp;无序容器的底层是哈希表，STL 的哈希表是由 vector 和 list 组成的。当空间不够的时候会倍增，表中所有数据在倍增后会重新 hash。STL 也允许自行传入 hash 函数和重组存储。


### 应用场合

- 不增删，静态存储，C 数组或者 array（STL 的静态数组）
- 需要动态增长，vector
- 增删大部分在头尾，deque
- 有大量增删，list
- 其他的容器比较有特点，按需使用


#### 迭代器失效

- vector, string
    - 插入时，如果存储空间重新分配，可能都失效，若没有重新分配，则插入之后迭代器，指针，引用可能失效。
    - 删除时，删除位置之后的迭代器，指针，引用都失效。
- deque 
    - 在首尾插入/删除，迭代器失效，但引用，指针不失效。
    - 在其他位置插入，迭代器，指针，引用都可能失效
    - 在其他位置删除，其他迭代器，引用，指针代都失效
- list, forward_list
    - 插入删除后迭代器，指针，引用仍然有效 (删除的那一个失效)

使用迭代器的策略：

- 最好每次增删或容量调整后重新定位现有迭代器
- 不要保存 end() 返回的迭代器，若元素有增删，每次都要调用 end() 进行判断
- 循环内使用 insert，erase 时要算清楚循环迭代器的位置，以及不同情况下是否该自增/自减



### STL 库

#### algorithm库

#### IO库

#### Fstream库



#### `<sstream>`

Q: 我怎样才能把整数转化为字符串？
A: 最简单的方法是使用stringstream ：

```C++
using namespace std;

string itos(int i)	// convert int to string
{
    stringstream s;
    s << i;
    return s.str();
}

int main()
{
    int i = 127;
    string ss = itos(i);
    const char* p = ss.c_str();

    cout << ss << " " << p << "\n";
}
 

```
当然，很自然地，你可以用这种方法来把任何可通过“<<”输出的类型转化为string。想知道string流的细节吗？参见《The C++ Programming Language》，21.5.3节。


#### `<utility>`

##### std::pair

```C++
pair<int, int> p{ 1,2 };
auto a = make_pair(1, 2);
```

```C++
pair<int, int> p{ 1,2 };
auto a = make_pair(1, 2);
	pair <string, string> author{"James", "Joyce"};
	cout << author.first << author.second << endl;
pair<type1, type2>	初始化一个pair
	默认对数据成员值初始化
	数据成员默认为public
make_pair(v1, v2)	返回一个从v1，v2推断类型的pair
return pair<string, int>();	可以返回pair，同时返回两个值
	
	
 <bitset> 常量长度的位数组

<bigNumber>?

#####  std::tuple


```C++
tuple<int, double, string> t;
string s = "asd";
auto b = make_tuple(1, 1.2, s);
auto &c = get<1>(b);
```

#### `<array>`

初始化
array<int, 10> ai;
array<string, 42> as;

#### `<random>`
https://blog.csdn.net/hejianhua/article/details/6204618

```C++
static default_random_engine e;
// e.min  == 1;
// e.max == 2147483646

// double (0,0 1.0)
static uniform_real_distribution<double> ud(0.0, 1.0);
for (size_t i = 0; i < 10; ++i)
	cout << ud(e) << endl;

// 用自己生成种子
e.seed(e());

// int(-10, 10)
static uniform_int_distribution<int> ui(-10, 10);
for (size_t i = 0; i < 10; ++i)
	cout << ui(e) << endl;
```


#### 正则表达式 `<regex>`


```C++
regex r("[^c]ei");
smatch results;
string s("the string need be searched");
regex_search(s, results, r);
```
#### 位 `<bitset>`

接受 `unsigned long long`

```C++

int i = 12345678;
bitset<32> b(i);	
cout << b.count() << endl;

bitset<32> sb("00110011");
cout << b << endl;
```


#### 替用运算符 `<ciso646>`

初等	替用	初等	替用	初等	替用
&&	and	~	compl	||	or
&=	and_eq	!	not	|=	or_eq
&	bitand	!=	not_eq	^	xor
|	bitor			^=	xor_eq


[返回目录](#Content)