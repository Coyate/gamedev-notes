---
layout: post
title: "程序基础"
date: 2018-10-25 20:24:39
update: 
categories: C++
img:
---

- [编译，链接，运行时](#编译链接运行时)
	- [头文件与源文件](#头文件与源文件)
	- [编译与链接](#编译与链接)
		- [各平台文件格式](#各平台文件格式)
		- [编译链接过程](#编译链接过程)
		- [目标文件](#目标文件)
		- [目标文件格式](#目标文件格式)
		- [目标文件存储结构](#目标文件存储结构)
		- [链接符号](#链接符号)
	- [main函数前后](#main函数前后)
- [程序的内存](#程序的内存)
	- [堆，栈，全局段](#堆栈全局段)
	- [栈](#栈)
	- [堆](#堆)
- [生命周期与作用域](#生命周期与作用域)
	- [临时量](#临时量)
- [内存要点](#内存要点)
	- [栈溢出](#栈溢出)
	- [大小端](#大小端)
	- [内存对齐](#内存对齐)
		- [类的存储](#类的存储)
	- [sizeof](#sizeof)
		- [`#pragma pack(n)`](#pragma-packn)
		- [位域](#位域)

### 编译，链接，运行时

时间上：写代码-编译-链接-运行时


#### 头文件与源文件

https://www.zhihu.com/question/58547318/answer/157433980
https://www.zhihu.com/question/280665935/answer/415360354


预处理器 Preprocessor
	1. 头文件保护符

``` C++
		#ifndef DATA_H
		#define DATA_H
		#endif
```

调试命令 Debug Command
/program <infile>Outfile
栈溢出的情况


#### 编译与链接

https://blog.csdn.net/jiange_zh/article/details/52187611


##### 各平台文件格式

平台 | 可执行文件 | 目标文件 | 动态库/共享对象 | 静态库
---|---|---|---|---
Windows|exe|obj|dll|lib
Unix/Linux|ELF、out|o|so|a
Mac|Mach-O|o|dylib、tbd、framework|a、framework

##### 编译链接过程

1. 预编译（预编译器处理如 `#include`、`#define` 等预编译指令，生成 `.i` 或 `.ii` 文件）
2. 编译（编译器进行词法分析、语法分析、语义分析、中间代码生成、目标代码生成、优化，生成 `.s` 文件）
3. 汇编（汇编器把汇编码翻译成机器码，生成 `.o` 文件）
4. 链接（连接器进行地址和空间分配、符号决议、重定位，生成 `.out` 文件）

> 现在版本 GCC 把预编译和编译合成一步，预编译编译程序 cc1、汇编器 as、连接器 ld

> MSVC 编译环境，编译器 cl、连接器 link、可执行文件查看器 dumpbin

##### 目标文件

编译器编译源代码后生成的文件叫做目标文件。目标文件从结构上讲，它是已经编译后的可执行文件格式，只是还没有经过链接的过程，其中可能有些符号或有些地址还没有被调整。

> 可执行文件（Windows 的 `.exe` 和 Linux 的 `ELF`）、动态链接库（Windows 的 `.dll` 和 Linux 的 `.so`）、静态链接库（Windows 的 `.lib` 和 Linux 的 `.a`）都是按照可执行文件格式存储（Windows 按照 PE-COFF，Linux 按照 ELF）

##### 目标文件格式

* Windows 的 PE（Portable Executable），或称为 PE-COFF，`.obj` 格式
* Linux 的 ELF（Executable Linkable Format），`.o` 格式
* Intel/Microsoft 的 OMF（Object Module Format）
* Unix 的 `a.out` 格式
* MS-DOS 的 `.COM` 格式

> PE 和 ELF 都是 COFF（Common File Format）的变种

##### 目标文件存储结构

段 | 功能
--- | ---
File Header | 文件头，描述整个文件的文件属性（包括文件是否可执行、是静态链接或动态连接及入口地址、目标硬件、目标操作系统等）
.text section | 代码段，执行语句编译成的机器代码 
.data section | 数据段，已初始化的全局变量和局部静态变量
.bss section | BSS 段（Block Started by Symbol），未初始化的全局变量和局部静态变量（因为默认值为 0，所以只是在此预留位置，不占空间）
.rodata section | 只读数据段，存放只读数据，一般是程序里面的只读变量（如 const 修饰的变量）和字符串常量
.comment section | 注释信息段，存放编译器版本信息
.note.GNU-stack section | 堆栈提示段 

> 其他段略

##### 链接符号

在链接中，目标文件之间相互拼合实际上是目标文件之间对地址的引用，即对函数和变量的地址的引用。我们将函数和变量统称为符号（Symbol），函数名或变量名就是符号名（Symbol Name）。

如下符号表（Symbol Table）：

Symbol（符号名） | Symbol Value （地址）
--- | ---
main| 0x100
Add | 0x123
... | ...


#### main函数


main函数
整个程序只能有一个，是程序入口
int main() {}
int main(int argc, char *argv[]) {}
int main(int argc, char **argv) {}
argv[0]默认保存程序的名字，argc最小值为1
	• main函数可以不写return语句，编译器会隐式返回0


#### main函数前后


https://www.cnblogs.com/yueqian-scut/p/3952263.html

https://www.cnblogs.com/findumars/p/6417932.html
https://www.cnblogs.com/carsonzhu/p/5276317.html
      Visual C++自带C++运行库的源代码启动函数的用途简单概括如下：

1）  获取新进程完整命令行的一个指针；

2）  获取指向新进程的环境变量的一个指针；

3）  初始化C/C++运行库的全局变量。

4）  初始化C运行库内存分配函数（malloc和calloc）和其他底层的I/O例程使用的堆。

5）  调用所有全局和静态C++类对象的构造函数。

第5条也就解释了为什么在main()函数前运行全局、静态变量的构造函数了。



main函数执行之前，主要就是初始化系统相关资源：
1.设置栈指针
2.初始化static静态和global全局变量，即data段的内容
3.将未初始化部分的赋初值：数值型short，int，long等为0，bool为FALSE，指针为NULL，等等，即.bss段的内容
4.运行全局构造器，估计是C++中构造函数之类的吧
5.将main函数的参数，argc，argv等传递给main函数，然后才真正运行main函数

main函数执行之后：
全局对象的析构函数会在main函数之后执行；
可以用_onexit 注册一个函数，它会在main 之后执行;
https://blog.csdn.net/jackzhang_123/article/details/79423044
https://blog.csdn.net/qq_29050863/article/details/78377726		


### 程序的内存

#### 堆，栈，全局段

 在C++中，内存区分为5个区，分别是堆、栈、自由存储区、全局/静态存储区、常量存储区；

 在C中，C内存区分为堆、栈、全局/静态存储区、常量存储区；
 
一般应用程序内存空间有如下区域：

* 栈：由操作系统自动分配释放，存放函数的参数值、局部变量等的值，用于维护函数调用的上下文
* 堆：一般由程序员分配释放，若程序员不释放，程序结束时可能由操作系统回收，用来容纳应用程序动态分配的内存区域
* 可执行文件映像：存储着可执行文件在内存中的映像，由装载器装载是将可执行文件的内存读取或映射到这里
* 保留区：保留区并不是一个单一的内存区域，而是对内存中受到保护而禁止访问的内存区域的总称，如通常 C 语言讲无效指针赋值为 0（NULL），因此 0 地址正常情况下不可能有效的访问数据

#### 栈

栈保存了一个函数调用所需要的维护信息，常被称为堆栈帧（Stack Frame）或活动记录（Activate Record），一般包含以下几方面：

* 函数的返回地址和参数
* 临时变量：包括函数的非静态局部变量以及编译器自动生成的其他临时变量
* 保存上下文：包括函数调用前后需要保持不变的寄存器

#### 堆

堆分配算法：

* 空闲链表（Free List）
* 位图（Bitmap）
* 对象池
* 
https://blog.csdn.net/fanx021/article/details/80630372
https://www.cnblogs.com/findumars/p/7545818.html
https://blog.csdn.net/qq369846642/article/details/47749389

栈，编译器自动分配释放，没有则栈溢出，栈一般2MB，编译时常数，硬件分配
（查询栈的物理位置）
堆，操作系统维护空间链表，虚拟内存大小，操作系统分配

数据段 字符串常量（实验）
代码段
BSS段 全局变量，静态变量，
BSS（Block Started by Symbol）通常是指用来存放程序中未初始化的全局变量和静态变量的一块内存区域。特点是:可读写的，在程序执行之前BSS段会自动清0。所以，未初始的全局变量在程序执行之前已经成0了。
数据段包括初始化的数据和未初始化的数据（BSS）两部分


https://blog.csdn.net/AS588AS/article/details/79213455
http://blog.sina.com.cn/s/blog_5ec742270100c13w.html


全局对象	程序开始时创建，结束时销毁	
局部自动对象	进入程序块时创建，离开块时销毁	栈内存
局部static对象	第一次使用时创建，程序结束时销毁	静态内存
动态分配对象	显式创建，显式销毁	堆内存

	• 字符串常量保存的位置
	char c1[] = "hellohell"; // 局部变量，保存在栈上
	*c1 = 't';
	char* c = "hellohell"; // 保存在只读数据段
	*c = 't'; // 抛出异常， 表示不可写入

	const char *a = "123"; const char *b = "123"; // a与b指向的位置相同

```C++
堆栈全局段
int global_int1 = 0;
int global_int2 = 0;

int main() {
	static int static_int1 = 0;
	static int static_int2 = 0;
	int int1 = 0;
	int int2 = 0;
	int *p_int1 = new int();
	int *p_int2 = new int();

	char *p_char = "bbbbbbb";

	char char_a[] = "aaaaaaa";
	char char_b[] = "aaaaaaa";
	char char_c[] = "ccccccc";
	// stack 
	printf("0x%08x \n", &int1);
	printf("0x%08x \n", &int2);

	printf("\n");
	// global
	printf("0x%08x \n", &global_int1);
	printf("0x%08x \n", &global_int2);
	printf("0x%08x \n", &static_int1);
	printf("0x%08x \n", &static_int2);

	printf("\n");
	// heap
	printf("0x%08x \n", &p_int1);
	printf("0x%08x \n", &p_int2);
	printf("0x%08x \n", &p_char);
	
	printf("\n");
	printf("0x%08x \n", char_a);
	printf("0x%08x \n", char_b);
	printf("0x%08x \n", char_c);
	return 0;
}


```



### 生命周期与作用域

作用域
	• 全局作用域的变量会被局部作用域的变量替代，可以通过全局作用域访问符访问
	
局部变量 local variable
局部对象的名字有作用域，对象有生命周期
局部对象通常都是自动对象（automatic object），执行定义语句时创建在栈上，在块末尾销毁
	• 局部变量会隐藏掉在外层的同名变量
	int foo = 1;
	void bar() {
		int foo = 2;
		cout << foo; // 2
	}

局部静态对象 local static object
在定义时初始化，直到程序终止时销毁


声明与定义
extern int i; // Only Declaration
int j; // Declaration and definition
extern double pi = 3.141596; // Only definition

	• 声明可以多次，定义只能有一次
	• 单纯声明是不创建变量的

例：
	int i = 1;
	void main() {
		int i = i;  // 在int i 出现时，i已经被声明
	}
不管有没有main外的定义，编译器都会提示使用了未初始化的变量i

https://blog.csdn.net/bzhxuexi/article/details/17253227

#### 临时量

https://blog.csdn.net/moon5555/article/details/79339439


### 内存要点

#### 栈溢出

一、局部数组过大。当函数内部的数组过大时，有可能导致堆栈溢出。
二、递归调用层次太多。递归函数在运行时会执行压栈操作，当压栈次数太多时，也会导致堆栈溢出。
三、指针或数组越界。这种情况最常见，例如进行字符串拷贝，或处理用户输入等等。

“段错误（segment fault）” 或 “非法操作，该内存地址不能 read/write”

典型的非法指针解引用造成的错误。当指针指向一个不允许读写的内存地址，而程序却试图利用指针来读或写该地址时，会出现这个错误。

普遍原因：

* 将指针初始化为 NULL，之后没有给它一个合理的值就开始使用指针
* 没用初始化栈中的指针，指针的值一般会是随机数，之后就直接开始使用指针
* 
#### 大小端

https://blog.csdn.net/infoworld/article/details/42131387
https://blog.csdn.net/wang57389675/article/details/52526251

```C++

int main()
{
short int a=0x1234;
cout<<hex<<(char)a<<endl;//输出4？？？
return 0;
}

int main()
{
short int a=0x1234;
printf("%x\n",(char)a);//输出34这个能理解
return 0;
}
```

大小端

union 
{
	unsigned char a;
	unsigned int i;
}u;

int main() {
	u.i = 0x12345678;
	cout << hex << u.i << endl;
	cout << hex << int(u.a) << endl;
	return 0;
}




#### 内存对齐

##### 类的存储

只padding，不调整
https://www.cnblogs.com/noryes/p/6434245.html

https://www.cnblogs.com/MyBlog-Richard/p/5993610.html

标准禁止对象大小为 0，因为两个不同的对象需要不同的地址表示

https://blog.csdn.net/worldwidehua/article/details/78200547

内有数组的结构体内存对齐	

内存对齐 Stuct Alignment
和数据相关的操作，例如Caching，Read，Write，每次的取指令地址要4个字节，所以数据一次不会只取1个字节。一般是一条指令取32/64字节的数据（甚至256），每批数据叫做Burst或Granule。但取数据流程还有其他的Burst，比如内存为32B Burst，read/store instruction burst 为4B，SSE Burst为16B。所以至少要按低Burst对齐，数据都要Align到2的幂，用空间换取更少的IO次数。
	• 对齐之后的数据，可以通过单条指令存取，如果没有对齐，则需要多个指令访问字边界的数据



	• 编译期决定的事情
	• 结构体内的成员和最长的成员对齐
	• 如果结构体中有潜入结构体成员，嵌入内层结构体也和最长的标量有相同的对齐
	struct A {
		char* cp;
		char c;
		// char[3] pad;
		int x;
	}
	struct B {
		int i ;
		bool b1;
		bool b2;
	}
	struct C {
		short s; // 2 bytes
		char c;  // 1 bytes
		int f:1; // 1 bits;
		int n:4; // 4 bits;
		int s:7; // 7 bits;
		// int pad1:4; // 4bits, total 16bits = 2 bytes
		// char pad2;  // 1 bytes;
	}

sizeof(name)	A	B	C
size	12	8	6

例：
	struct S {
		int i;
		int *p;
	};
	// 结构体中，p在i之后
	int main() {
		S s;
		int *p = &s.i; // p指向i
		p[0] = 4; // p[0]指向s.i，s.i = 4
		p[1] = 3; // p[1] 指向 s.p, s.p = 0x0003
		s.p = p;  // s.p = p, 即s.p 指向 s.i
		s.p[1] = 1; // s.p[1] 指向s.p本身，s.p = 0x0001
		s.p[0] = 2; // 0x0001 = 2，未使用的地址，程序崩溃
	}

struct K {
	int a;
	char r[7];
	short b;
};
sizeof(K) == 16





#### sizeof
https://blog.csdn.net/wangshubo1989/article/details/
sizeof 是个宏，不做运算
i=0；
sizeof（i++）


 sizeof()

* sizeof 对数组，得到整个数组所占空间大小。
* sizeof 对指针，得到指针本身所占空间大小。



1. sizeof会被编译成一个编译期常量，内部代码会直接删掉，在运行时不存在（decltype类似）
		a. sizeof(*p) 是求指针指向的内容的大小，即使未初始化也是安全的
		b. sizeof(++i)括号内的(++i)不执行
2. sizeof 操作一维静态数组会得到整个数组的大小（单个对象 * 数组size），而不会把数组当指针
		- 数组在传递进函数之后会退化为指针
3. sizeof 对vector和string操作只会得到固定部分的大小，vector<int>() 16, string 28
	sizeof(vector<int>()) = 16，包含了3个int*指针，一个allocator(1字节+padding)
	sizeof(vector<int>()) = 32，在64位下
4. sizeof 结果是常量表达式，可以用声明数组
	int arr[ sizeof(ia) / sizeof(*ia)]
5. 不能对函数类型，不完整类型求sizeof

	char* ss1 = "0123456789";
	char  ss2[]= "0123456789";
	char  ss3[100] = "0123456789";
	int   ss4[100];
	char* ss5 = (char *)malloc(100);
	int*  ss6 = (int *)malloc(100);
	
	char str1[] = "fooaaa"; //0x00b8fc28
	char str2[] = "fooaaa"; //0x00b8fc18

	char* str3 = "fooaaa"; //0x00a43bcc
	char* str4 = "fooaaa"; //0x00a43bcc
	
	struct A {
		short a1;
		short a2;
		short a3;
	}
	
	struct B {
		long a1;
		short a2;
	}
	
	
	
sizeof(name)	ss1	ss2	ss3	ss4	ss5	ss6
size	4	11	100	400	4	4
sizeof(name)	str1	str2	str3	str4	A	B
						
size	7	7	4	4	6	8
						
• 空类型，虚继承的空类的大小
    class A { };
    class B { };
    class C : public virtual B {};
    class D : public A, public B {};
    class E { virtual ~E() {} };
name    A   B   C   D   E
sizeof(name)    1   1   4   1   4
虚继承和虚函数都会建立虚表，类中存储指向虚表的指针


	本质	参数	返回类型	时间	形式
sizeof	运算符	类型	size_t	编译期	sizeof x/
					sizeof (x)
strlen	函数	(const) char* 	int	运行时	strlen(x)


sizeof vs strlen

https://www.cnblogs.com/carekee/articles/1630789.html



##### `#pragma pack(n)`

设定结构体、联合以及类成员变量以 n 字节方式对齐

<details><summary>#pragma pack(n) 使用</summary> 


```cpp
// #pragma pack(push)  // 保存对齐状态
// #pragma pack(4)     // 设定为 4 字节对齐

struct test
{
    char m1;
    double m4;
    int m3;
};

// #pragma pack(pop)   // 恢复对齐状态
```

</details>




##### 位域

在类的内部连续定义的位域会被压缩在同一整数的相邻位置，但能否压缩是和机器相关的（有符号位域依赖具体实现，无符号位域更加稳妥）
```C++
struct bitMode {
	unsigned int a : 2;
	unsigned int b : 1;
	unsigned int c : 3;
	unsigned int d : 4;
	unsigned int e : 9;
}
```

```cpp
Bit mode: 2;    // mode 占 2 位
```

类可以将其（非静态）数据成员定义为位域（bit-field），在一个位域中含有一定数量的二进制位。当一个程序需要向其他程序或硬件设备传递二进制数据时，通常会用到位域。

* 位域在内存中的布局是与机器有关的
* 位域的类型必须是整型或枚举类型，带符号类型中的位域的行为将因具体实现而定
* 取地址运算符（&）不能作用于位域，任何指针都无法指向类的位域


